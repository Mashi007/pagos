"""
Endpoints de reportes. Datos reales desde BD.
Dashboard resumen, cartera, pagos, morosidad, financiero, asesores, productos.
ExportaciÃ³n Excel y PDF para cada tipo segÃºn corresponda.
"""
import calendar
import io
from datetime import date, datetime, timezone, timedelta
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, Query
from fastapi.responses import Response
from sqlalchemy import func, select, and_, or_, delete
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.deps import get_current_user
from app.models.cliente import Cliente
from app.models.cuota import Cuota
from app.models.pago import Pago
from app.models.prestamo import Prestamo
from app.models.reporte_contable_cache import ReporteContableCache

router = APIRouter(dependencies=[Depends(get_current_user)])


def _safe_float(val) -> float:
    if val is None:
        return 0.0
    try:
        return float(val)
    except (TypeError, ValueError):
        return 0.0


def _parse_fecha(s: Optional[str]) -> date:
    if not s:
        return date.today()
    try:
        return date.fromisoformat(s)
    except ValueError:
        return date.today()


def _periodos_desde_filtros(
    aÃ±os_str: Optional[str],
    meses_str: Optional[str],
    meses_default: int = 12,
) -> List[tuple]:
    """
    Retorna lista de (aÃ±o, mes) ordenada descendente.
    Si aÃ±os_str y meses_str estÃ¡n presentes, usa esos. Si no, usa Ãºltimos meses_default meses.
    """
    if aÃ±os_str and meses_str:
        try:
            aÃ±os = sorted([int(x.strip()) for x in aÃ±os_str.split(",") if x.strip()], reverse=True)
            meses = sorted([int(x.strip()) for x in meses_str.split(",") if x.strip() and 1 <= int(x.strip()) <= 12])
            if aÃ±os and meses:
                periodos = [(a, m) for a in aÃ±os for m in meses]
                periodos.sort(key=lambda p: (-p[0], -p[1]))
                return periodos
        except (ValueError, TypeError):
            pass
    hoy = date.today()
    result = []
    for i in range(meses_default):
        aÃ±o = hoy.year
        mes = hoy.month - i
        while mes <= 0:
            mes += 12
            aÃ±o -= 1
        result.append((aÃ±o, mes))
    return result


# ---------- Dashboard resumen ----------
@router.get("/dashboard/resumen")
def get_resumen_dashboard(db: Session = Depends(get_db)):
    """
    Resumen para el dashboard de reportes: total_clientes, total_prestamos, total_pagos,
    cartera_activa, prestamos_mora, pagos_mes, fecha_actualizacion. Datos reales desde BD.
    """
    hoy = date.today()
    now_utc = datetime.now(timezone.utc)
    inicio_mes = hoy.replace(day=1)

    # KPIs solo incluyen clientes ACTIVOS
    total_clientes = db.scalar(
        select(func.count()).select_from(Cliente).where(Cliente.estado == "ACTIVO")
    ) or 0
    total_prestamos = db.scalar(
        select(func.count())
        .select_from(Prestamo)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(Cliente.estado == "ACTIVO", Prestamo.estado == "APROBADO")
    ) or 0
    total_pagos = db.scalar(
        select(func.count())
        .select_from(Cuota)
        .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(
            Cliente.estado == "ACTIVO",
            Prestamo.estado == "APROBADO",
            Cuota.fecha_pago.isnot(None),
        )
    ) or 0
    cartera_activa = db.scalar(
        select(func.coalesce(func.sum(Cuota.monto), 0))
        .select_from(Cuota)
        .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(
            Cliente.estado == "ACTIVO",
            Prestamo.estado == "APROBADO",
            Cuota.fecha_pago.is_(None),
        )
    ) or 0
    subq_mora = (
        select(Cuota.prestamo_id)
        .select_from(Cuota)
        .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(
            Cliente.estado == "ACTIVO",
            Prestamo.estado == "APROBADO",
            Cuota.fecha_pago.is_(None),
            Cuota.fecha_vencimiento < (hoy - timedelta(days=89)),  # MOROSO: vencido hace 90+ dÃ­as
        )
        .distinct()
    )
    prestamos_mora = db.scalar(select(func.count()).select_from(subq_mora.subquery())) or 0
    # Monto total cobrado este mes (cuotas con fecha_pago en el mes actual)
    pagos_mes = _safe_float(
        db.scalar(
            select(func.coalesce(func.sum(Cuota.monto), 0))
            .select_from(Cuota)
            .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.estado == "APROBADO",
                Cuota.fecha_pago.isnot(None),
                func.date(Cuota.fecha_pago) >= inicio_mes,
                func.date(Cuota.fecha_pago) <= hoy,
            )
        )
        or 0
    )

    return {
        "total_clientes": total_clientes,
        "total_prestamos": total_prestamos,
        "total_pagos": total_pagos,
        "cartera_activa": _safe_float(cartera_activa),
        "pagos_vencidos": prestamos_mora,
        "pagos_mes": pagos_mes,
        "fecha_actualizacion": now_utc.isoformat(),
    }


