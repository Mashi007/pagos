@router.get("/asesores/por-mes")
def get_asesores_por_mes(
    db: Session = Depends(get_db),
    meses: int = Query(12, ge=1, le=24, description="Cantidad de meses hacia atrÃ¡s"),
    aÃ±os: Optional[str] = Query(None),
    meses_list: Optional[str] = Query(None),
):
    """Asesores por mes: una pestaÃ±a por mes. Solo lo que sucede en ese mes: cuotas con fecha_vencimiento en el mes y sin pagar."""
    resultado: dict = {"meses": []}
    periodos = _periodos_desde_filtros(aÃ±os, meses_list, meses)

    for (aÃ±o, mes) in periodos:
        inicio = date(aÃ±o, mes, 1)
        _, ultimo = calendar.monthrange(aÃ±o, mes)
        fin = date(aÃ±o, mes, ultimo)

        # Solo cuotas que vencieron en este mes (fecha_vencimiento en el mes) y no estÃ¡n pagadas
        rows = db.execute(
            select(
                Prestamo.analista,
                func.coalesce(func.sum(Cuota.monto), 0).label("vencimiento_total"),
                func.count(func.distinct(Cuota.prestamo_id)).label("total_prestamos"),
            )
            .select_from(Cuota)
            .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.estado == "APROBADO",
                Cuota.fecha_pago.is_(None),
                Cuota.fecha_vencimiento >= inicio,
                Cuota.fecha_vencimiento <= fin,
            )
            .group_by(Prestamo.analista)
            .order_by(func.sum(Cuota.monto).desc())
        ).fetchall()

        items = [
            {
                "analista": r.analista or "Sin asignar",
                "vencimiento_total": round(_safe_float(r.vencimiento_total), 2),
                "total_prestamos": r.total_prestamos or 0,
            }
            for r in rows
        ]

        resultado["meses"].append({
            "mes": mes,
            "aÃ±o": aÃ±o,
            "label": f"{mes:02d}/{aÃ±o}",
            "items": items,
        })

    return resultado


@router.get("/asesores")
def get_reporte_asesores(
    db: Session = Depends(get_db),
    fecha_corte: Optional[str] = Query(None),
):
    """Reporte por asesor/analista. Datos reales desde BD (solo clientes ACTIVOS)."""
    fc = _parse_fecha(fecha_corte)
    analistas = db.execute(
        select(Prestamo.analista)
        .select_from(Prestamo)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(Cliente.estado == "ACTIVO", Prestamo.estado == "APROBADO")
        .distinct()
    ).fetchall()
    resumen_por_analista: List[dict] = []
    for (analista,) in analistas:
        if not analista:
            continue
        prestamos = db.execute(
            select(Prestamo.id)
            .select_from(Prestamo)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.analista == analista,
                Prestamo.estado == "APROBADO",
            )
        ).fetchall()
        ids = [x[0] for x in prestamos]
        total_prestamos = len(ids)
        total_clientes = db.scalar(select(func.count(func.distinct(Prestamo.cliente_id))).select_from(Prestamo).where(Prestamo.id.in_(ids))) or 0
        cartera_total = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.is_(None), Cuota.prestamo_id.in_(ids)))) or 0
        morosidad_total = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.is_(None), Cuota.fecha_vencimiento < fc, Cuota.prestamo_id.in_(ids)))) or 0
        total_cobrado = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.isnot(None), Cuota.prestamo_id.in_(ids)))) or 0
        porcentaje_cobrado = (total_cobrado / (total_cobrado + cartera_total) * 100) if (total_cobrado + cartera_total) else 0
        porcentaje_morosidad = (morosidad_total / cartera_total * 100) if cartera_total else 0
        resumen_por_analista.append({
            "analista": analista,
            "total_prestamos": total_prestamos,
            "total_clientes": total_clientes,
            "cartera_total": cartera_total,
            "morosidad_total": morosidad_total,
            "total_cobrado": total_cobrado,
            "porcentaje_cobrado": round(porcentaje_cobrado, 2),
            "porcentaje_morosidad": round(porcentaje_morosidad, 2),
        })
    return {
        "fecha_corte": fc.isoformat(),
        "resumen_por_analista": resumen_por_analista,
        "desempeno_mensual": [],
        "clientes_por_analista": [],
    }


def _generar_excel_asesores_por_mes(data_por_mes: dict) -> bytes:
    """Genera Excel con una pestaÃ±a por mes (MM/YYYY). Solo datos del mes reportado. Columnas: Analista, Total prÃ©stamos, Total vencimiento."""
    import openpyxl
    from openpyxl.styles import numbers
    from datetime import datetime
    
    wb = openpyxl.Workbook()
    meses_data = data_por_mes.get("meses", [])

    # Diccionario de meses en espaÃ±ol
    meses_es = {
        1: "Enero", 2: "Febrero", 3: "Marzo", 4: "Abril", 5: "Mayo", 6: "Junio",
        7: "Julio", 8: "Agosto", 9: "Septiembre", 10: "Octubre", 11: "Noviembre", 12: "Diciembre"
    }

    for idx, mes_data in enumerate(meses_data):
        mes = mes_data.get("mes", 1)
        aÃ±o = mes_data.get("aÃ±o", datetime.now().year)
        mes_nombre = meses_es.get(mes, "")
        label = mes_data.get("label", f"{mes:02d}/{aÃ±o}")
        sheet_name = f"{mes_nombre} {aÃ±o}"[:31]
        
        if idx == 0:
            ws = wb.active
            ws.title = sheet_name
        else:
            ws = wb.create_sheet(title=sheet_name)

        ws.append(["Reporte de Analistas", label])
        ws.append(["Solo cuotas que vencieron en este mes y no estÃ¡n pagadas"])
        ws.append([])
        ws.append(["Analista", "Total prÃ©stamos", "Total vencimiento ($)"])
        
        for r in mes_data.get("items", []):
            row_num = ws.max_row + 1
            ws.append([
                r.get("analista", ""), 
                r.get("total_prestamos", 0), 
                r.get("vencimiento_total", 0)
            ])
            # Aplicar formato contable con 2 decimales a la columna C (Total vencimiento)
            cell = ws.cell(row=row_num, column=3)
            cell.number_format = '#,##0.00'

    buf = io.BytesIO()
    wb.save(buf)
    return buf.getvalue()


# DEPRECATED: Este endpoint fue reemplazado por /exportar/morosidad
# El reporte de asesores ahora se genera desde el endpoint de morosidad (agrupado por cÃ©dula)
# Se mantiene comentado para referencia histÃ³rica
# @router.get("/exportar/asesores")
# def exportar_asesores(
#     db: Session = Depends(get_db),
#     formato: str = Query("excel", pattern="^(excel|pdf)$"),
#     fecha_corte: Optional[str] = Query(None),
#     meses: int = Query(12, ge=1, le=24, description="Para Excel: cantidad de meses (una pestaÃ±a por mes)"),
#     aÃ±os: Optional[str] = Query(None),
#     meses_list: Optional[str] = Query(None),
# ):
#     """DEPRECATED: Exporta reporte asesores. Excel: una pestaÃ±a por mes (MM/YYYY), solo datos del mes. PDF: fecha de corte Ãºnica."""
#     if formato == "excel":
#         data_por_mes = get_asesores_por_mes(db=db, meses=meses, aÃ±os=aÃ±os, meses_list=meses_list)
#         content = _generar_excel_asesores_por_mes(data_por_mes)
#         hoy_str = date.today().isoformat()
#         return Response(
#             content=content,
#             media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
#             headers={"Content-Disposition": f"attachment; filename=reporte_asesores_{hoy_str}.xlsx"},
#         )
#     data = get_reporte_asesores(db=db, fecha_corte=fecha_corte)
#     import openpyxl
#     wb = openpyxl.Workbook()
#     ws = wb.active
#     ws.title = "Asesores"
#     ws.append(["Analista", "PrÃ©stamos", "Clientes", "Cartera", "Vencimiento", "Cobrado", "% Cobrado", "% Vencimiento"])
#     for r in data.get("resumen_por_analista", []):
#         ws.append([r.get("analista", ""), r.get("total_prestamos", 0), r.get("total_clientes", 0), r.get("cartera_total", 0), r.get("morosidad_total", 0), r.get("total_cobrado", 0), r.get("porcentaje_cobrado", 0), r.get("porcentaje_morosidad", 0)])
#     buf = io.BytesIO()
#     wb.save(buf)
#     content = buf.getvalue()
#     if formato == "pdf":
#         pdf_content = _generar_pdf_asesores(data)
#         return Response(content=pdf_content, media_type="application/pdf", headers={"Content-Disposition": f"attachment; filename=reporte_asesores_{data['fecha_corte']}.pdf"})
#     return Response(content=content, media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", headers={"Content-Disposition": f"attachment; filename=reporte_asesores_{data['fecha_corte']}.xlsx"})


def _generar_pdf_asesores(data: dict) -> bytes:
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet
    buf = io.BytesIO()
    doc = SimpleDocTemplate(buf, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []
    story.append(Paragraph("Reporte de Asesores", styles["Title"]))
    story.append(Paragraph(f"Fecha de corte: {data.get('fecha_corte', '')}", styles["Normal"]))
    story.append(Spacer(1, 12))
    rows = [["Analista", "PrÃ©stamos", "Clientes", "Cartera", "Vencimiento", "Cobrado", "% Cobrado", "% Vencimiento"]]
    for r in data.get("resumen_por_analista", []):
        rows.append([r.get("analista", ""), str(r.get("total_prestamos", 0)), str(r.get("total_clientes", 0)), str(r.get("cartera_total", 0)), str(r.get("morosidad_total", 0)), str(r.get("total_cobrado", 0)), str(r.get("porcentaje_cobrado", 0)), str(r.get("porcentaje_morosidad", 0))])
    t = Table(rows)
    t.setStyle(TableStyle([("BACKGROUND", (0, 0), (-1, 0), "#e0e0e0"), ("GRID", (0, 0), (-1, -1), 0.5, "#ccc")]))
    story.append(t)
    doc.build(story)
    return buf.getvalue()


# ---------- Reporte Productos ----------
@router.get("/productos/por-mes")
def get_productos_por_mes(
    db: Session = Depends(get_db),
    meses: int = Query(12, ge=1, le=24, description="Cantidad de meses hacia atrÃ¡s"),
    aÃ±os: Optional[str] = Query(None),
    meses_list: Optional[str] = Query(None),
):
    """Productos por mes: una pestaÃ±a por mes. Columnas: Modelo vehÃ­culo, Total financiamiento, Valor activo (70%)."""
    resultado: dict = {"meses": []}
    periodos = _periodos_desde_filtros(aÃ±os, meses_list, meses)
    fecha_ref = func.coalesce(func.date(Prestamo.fecha_aprobacion), func.date(Prestamo.fecha_registro))

    for (aÃ±o, mes) in periodos:
        inicio = date(aÃ±o, mes, 1)
        _, ultimo = calendar.monthrange(aÃ±o, mes)
        fin = date(aÃ±o, mes, ultimo)

        rows = db.execute(
            select(
                Prestamo.modelo_vehiculo,
                func.coalesce(func.sum(Prestamo.total_financiamiento), 0).label("total_financiamiento"),
            )
            .select_from(Prestamo)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.estado == "APROBADO",
                fecha_ref >= inicio,
                fecha_ref <= fin,
            )
            .group_by(Prestamo.modelo_vehiculo)
            .order_by(func.sum(Prestamo.total_financiamiento).desc())
        ).fetchall()

        items = []
        for r in rows:
            total_fin = round(_safe_float(r.total_financiamiento), 2)
            valor_activo = round(total_fin * 0.70, 2)
            items.append({
                "modelo": r.modelo_vehiculo or "Sin modelo",
                "total_financiamiento": total_fin,
                "valor_activo": valor_activo,
            })

        resultado["meses"].append({
            "mes": mes,
            "aÃ±o": aÃ±o,
            "label": f"{mes:02d}/{aÃ±o}",
            "items": items,
        })

    return resultado


@router.get("/productos")
def get_reporte_productos(
    db: Session = Depends(get_db),
    fecha_corte: Optional[str] = Query(None),
):
    """Reporte por producto. Datos reales desde BD."""
    fc = _parse_fecha(fecha_corte)
    productos = db.execute(
        select(Prestamo.producto)
        .select_from(Prestamo)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(Cliente.estado == "ACTIVO", Prestamo.estado == "APROBADO")
        .distinct()
    ).fetchall()
    resumen_por_producto: List[dict] = []
    for (producto,) in productos:
        if not producto:
            continue
        prestamos = db.execute(
            select(Prestamo.id)
            .select_from(Prestamo)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.producto == producto,
                Prestamo.estado == "APROBADO",
            )
        ).fetchall()
        ids = [x[0] for x in prestamos]
        total_prestamos = len(ids)
        total_clientes = db.scalar(select(func.count(func.distinct(Prestamo.cliente_id))).select_from(Prestamo).where(Prestamo.id.in_(ids))) or 0
        cartera_total = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.is_(None), Cuota.prestamo_id.in_(ids)))) or 0
        promedio_prestamo = _safe_float(db.scalar(select(func.avg(Prestamo.total_financiamiento)).select_from(Prestamo).where(Prestamo.id.in_(ids)))) or 0
        total_cobrado = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.isnot(None), Cuota.prestamo_id.in_(ids)))) or 0
        morosidad_total = _safe_float(db.scalar(select(func.coalesce(func.sum(Cuota.monto), 0)).select_from(Cuota).where(Cuota.fecha_pago.is_(None), Cuota.fecha_vencimiento < fc, Cuota.prestamo_id.in_(ids)))) or 0
        porcentaje_cobrado = (total_cobrado / (total_cobrado + cartera_total) * 100) if (total_cobrado + cartera_total) else 0
        resumen_por_producto.append({
            "producto": producto,
            "total_prestamos": total_prestamos,
            "total_clientes": total_clientes,
            "cartera_total": cartera_total,
            "promedio_prestamo": round(promedio_prestamo, 2),
            "total_cobrado": total_cobrado,
            "morosidad_total": morosidad_total,
            "porcentaje_cobrado": round(porcentaje_cobrado, 2),
        })
    productos_por_concesionario: List[dict] = []
    concesionarios = db.execute(
        select(Prestamo.concesionario)
        .select_from(Prestamo)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(Cliente.estado == "ACTIVO", Prestamo.estado == "APROBADO")
        .distinct()
    ).fetchall()
    for (conc,) in concesionarios:
        if not conc:
            continue
        for (producto,) in productos:
            if not producto:
                continue
            cnt = db.scalar(
                select(func.count())
                .select_from(Prestamo)
                .join(Cliente, Prestamo.cliente_id == Cliente.id)
                .where(
                    Cliente.estado == "ACTIVO",
                    Prestamo.concesionario == conc,
                    Prestamo.producto == producto,
                    Prestamo.estado == "APROBADO",
                )
            ) or 0
            if cnt:
                monto = _safe_float(
                    db.scalar(
                        select(func.sum(Prestamo.total_financiamiento))
                        .select_from(Prestamo)
                        .join(Cliente, Prestamo.cliente_id == Cliente.id)
                        .where(
                            Cliente.estado == "ACTIVO",
                            Prestamo.concesionario == conc,
                            Prestamo.producto == producto,
                            Prestamo.estado == "APROBADO",
                        )
                    )
                    or 0
                )
                productos_por_concesionario.append({"concesionario": conc, "producto": producto, "cantidad_prestamos": cnt, "monto_total": monto})
    return {
        "fecha_corte": fc.isoformat(),
        "resumen_por_producto": resumen_por_producto,
        "productos_por_concesionario": productos_por_concesionario,
        "tendencia_mensual": [],
    }


def _generar_excel_productos_por_mes(data_por_mes: dict) -> bytes:
    """Genera Excel con una pestaÃ±a por mes (MM/YYYY). Columnas: Modelo vehÃ­culo | Total financiamiento | Valor activo (70%)."""
    import openpyxl
    from datetime import datetime
    
    wb = openpyxl.Workbook()
    meses_data = data_por_mes.get("meses", [])

    # Diccionario de meses en espaÃ±ol
    meses_es = {
        1: "Enero", 2: "Febrero", 3: "Marzo", 4: "Abril", 5: "Mayo", 6: "Junio",
        7: "Julio", 8: "Agosto", 9: "Septiembre", 10: "Octubre", 11: "Noviembre", 12: "Diciembre"
    }

    for idx, mes_data in enumerate(meses_data):
        mes = mes_data.get("mes", 1)
        aÃ±o = mes_data.get("aÃ±o", datetime.now().year)
        mes_nombre = meses_es.get(mes, "")
        label = mes_data.get("label", f"{mes:02d}/{aÃ±o}")
        sheet_name = f"{mes_nombre} {aÃ±o}"[:31]  # TÃ­tulo en espaÃ±ol con lÃ­mite de 31 caracteres
        
        if idx == 0:
            ws = wb.active
            ws.title = sheet_name
        else:
            ws = wb.create_sheet(title=sheet_name)

        # Encabezado
        ws.append(["Reporte de Productos", label])
        ws.append([])
        ws.append(["Modelo de vehÃ­culo", "Total financiamiento ($)", "Valor del activo ($)"])
        
        # Datos
        items = mes_data.get("items", [])
        if items:
            for r in items:
                ws.append([
                    r.get("modelo", ""),
                    r.get("total_financiamiento", 0),
                    r.get("valor_activo", 0),
                ])
        else:
            # Si no hay datos, agregar fila informativa
            ws.append(["Sin datos", 0, 0])

    buf = io.BytesIO()
    wb.save(buf)
    return buf.getvalue()


@router.get("/exportar/productos")
def exportar_productos(
    db: Session = Depends(get_db),
    formato: str = Query("excel", pattern="^(excel|pdf)$"),
    fecha_corte: Optional[str] = Query(None),
    meses: int = Query(12, ge=1, le=24, description="Para Excel: cantidad de meses (una pestaÃ±a por mes)"),
    aÃ±os: Optional[str] = Query(None),
    meses_list: Optional[str] = Query(None),
):
    """Exporta reporte productos. Excel: una pestaÃ±a por mes (MM/YYYY), columnas Modelo | Total financiamiento | Valor activo (70%). PDF: clÃ¡sico."""
    if formato == "excel":
        data_por_mes = get_productos_por_mes(db=db, meses=meses, aÃ±os=aÃ±os, meses_list=meses_list)
        content = _generar_excel_productos_por_mes(data_por_mes)
        hoy_str = date.today().isoformat()
        return Response(
            content=content,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename=reporte_productos_{hoy_str}.xlsx"},
        )
    data = get_reporte_productos(db=db, fecha_corte=fecha_corte)
    import openpyxl
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Productos"
    ws.append(["Producto", "PrÃ©stamos", "Clientes", "Cartera", "Promedio", "Cobrado", "Mora", "% Cobrado"])
    for r in data.get("resumen_por_producto", []):
        ws.append([r.get("producto", ""), r.get("total_prestamos", 0), r.get("total_clientes", 0), r.get("cartera_total", 0), r.get("promedio_prestamo", 0), r.get("total_cobrado", 0), r.get("morosidad_total", 0), r.get("porcentaje_cobrado", 0)])
    buf = io.BytesIO()
    wb.save(buf)
    content = buf.getvalue()
    if formato == "pdf":
        pdf_content = _generar_pdf_productos(data)
        return Response(content=pdf_content, media_type="application/pdf", headers={"Content-Disposition": f"attachment; filename=reporte_productos_{data['fecha_corte']}.pdf"})
    return Response(content=content, media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", headers={"Content-Disposition": f"attachment; filename=reporte_productos_{data['fecha_corte']}.xlsx"})


