name: üöÄ CI/CD Pipeline - Sistema de Pr√©stamos y Cobranza

# Trigger del pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch: # Permite ejecuci√≥n manual

# Variables globales
env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  BACKEND_DIR: './backend'
  FRONTEND_DIR: './frontend'

jobs:
  # ========================================
  # üîç AN√ÅLISIS DE C√ìDIGO Y CALIDAD
  # ========================================
  code-quality:
    name: üîç An√°lisis de Calidad de C√≥digo
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Para an√°lisis completo de git
      
      - name: üêç Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
          pip install flake8 black isort mypy
      
      - name: üîç Linting con flake8
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üîç Ejecutando flake8 - errores cr√≠ticos..."
          echo "::group::Flake8 - Errores Cr√≠ticos"
          # Ejecutar sin || true para que bloquee en errores cr√≠ticos (sintaxis, funciones no definidas)
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics 2>&1 | tee flake8-critical-output.txt
          FLAKE8_CRITICAL_EXIT=${PIPESTATUS[0]}
          cat flake8-critical-output.txt
          echo "::endgroup::"
          
          echo "üîç Ejecutando flake8 - an√°lisis completo..."
          echo "::group::Flake8 - An√°lisis Completo"
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          echo "::endgroup::"
          
          # Guardar en archivos para artifacts (siempre generar logs)
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics > flake8-critical.log 2>&1 || true
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics > flake8-full.log 2>&1
          
          # Fallar si hubo errores cr√≠ticos
          if [ $FLAKE8_CRITICAL_EXIT -ne 0 ]; then
            echo "‚ùå ERROR: Errores cr√≠ticos de Flake8 detectados (sintaxis, funciones no definidas)."
            echo "Revisa flake8-critical.log para m√°s detalles."
            exit 1
          fi
      
      - name: üé® Formateo con black
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üé® Ejecutando black (verificaci√≥n)..."
          echo "::group::Black - Verificaci√≥n de Formato"
          black --check --diff app/ || true
          echo "::endgroup::"
          # Tambi√©n guardar en archivo para artifacts
          black --check --diff app/ > black.log 2>&1 || true
      
      - name: üîß Aplicar correcciones de Black autom√°ticamente
        run: |
          cd ${{ env.BACKEND_DIR }}
          # Solo aplicar si el √∫ltimo commit no fue de Black
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
          if ! echo "$LAST_COMMIT_MSG" | grep -qi "black"; then
            # Sincronizar con remoto antes de aplicar cambios para evitar divergencias
            git pull --rebase origin main || echo "‚ö†Ô∏è No se pudo hacer pull (puede ser normal si no hay cambios remotos)"
            black app/
            if ! git diff --quiet; then
              git config user.name "GitHub Actions"
              git config user.email "actions@github.com"
              git add app/
              git commit -m "style: Aplicar correcciones autom√°ticas de Black [skip ci]"
              git push
              echo "‚úÖ Correcciones de Black commiteadas y pusheadas"
            else
              echo "‚úÖ No se requieren correcciones de Black"
            fi
          else
            echo "‚è≠Ô∏è  √öltimo commit fue de Black, saltando correcci√≥n autom√°tica"
          fi
      
      - name: üìù Ordenamiento de imports con isort
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üìù Verificando orden de imports con isort..."
          echo "::group::Isort - Verificaci√≥n de Imports"
          # Generar log primero - NO fallar el pipeline aqu√≠
          isort --check-only --diff app/ > isort.log 2>&1 || true
          ISORT_EXIT_CODE=${PIPESTATUS[0]}
          # Mostrar output
          cat isort.log
          echo "::endgroup::"
          # NO hacer exit aqu√≠ - permitir que la correcci√≥n autom√°tica se ejecute
      
      - name: üîß Aplicar correcciones de Isort autom√°ticamente
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üîß Aplicando correcciones autom√°ticas de Isort..."
          # Solo aplicar si el √∫ltimo commit no fue de Isort
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
          if ! echo "$LAST_COMMIT_MSG" | grep -qi "isort"; then
            # Sincronizar con remoto antes de aplicar cambios para evitar divergencias
            git pull --rebase origin main || echo "‚ö†Ô∏è No se pudo hacer pull (puede ser normal si no hay cambios remotos)"
            # Aplicar correcciones
            isort app/
            if ! git diff --quiet; then
              echo "üìù Correcciones de Isort aplicadas. Haciendo commit..."
              git config user.name "GitHub Actions"
              git config user.email "actions@github.com"
              git add app/
              git commit -m "style: Aplicar correcciones autom√°ticas de Isort [skip ci]"
              git push
              echo "‚úÖ Correcciones de Isort commiteadas y pusheadas"
            else
              echo "‚úÖ No se requieren correcciones de Isort"
            fi
          else
            echo "‚è≠Ô∏è  √öltimo commit fue de Isort, saltando correcci√≥n autom√°tica"
          fi
      
      - name: üîí Verificaci√≥n de tipos con mypy
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üîí Ejecutando verificaci√≥n de tipos con mypy..."
          echo "::group::Mypy - Verificaci√≥n de Tipos"
          mypy app/ --ignore-missing-imports || true
          echo "::endgroup::"
          # Tambi√©n guardar en archivo para artifacts
          mypy app/ --ignore-missing-imports > mypy.log 2>&1 || true
      
      # Verificar que los logs existan antes de subirlos
      - name: üîç Verificar logs generados
        if: always()
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "üîç Verificando archivos de log generados..."
          ls -lh *.log 2>/dev/null || echo "‚ö†Ô∏è No se encontraron archivos .log"
          echo ""
          echo "üìã Archivos encontrados:"
          for log in flake8-critical.log flake8-full.log black.log isort.log mypy.log; do
            if [ -f "$log" ]; then
              size=$(du -h "$log" | cut -f1)
              lines=$(wc -l < "$log" 2>/dev/null || echo "0")
              echo "  ‚úÖ $log: $size ($lines l√≠neas)"
            else
              echo "  ‚ö†Ô∏è $log: NO ENCONTRADO"
            fi
          done
      
      # Guardar TODOS los logs como artifacts descargables
      - name: üìä Subir logs de calidad de c√≥digo
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: code-quality-logs-${{ github.run_number }}
          retention-days: 90
          path: |
            ${{ env.BACKEND_DIR }}/flake8-critical.log
            ${{ env.BACKEND_DIR }}/flake8-full.log
            ${{ env.BACKEND_DIR }}/black.log
            ${{ env.BACKEND_DIR }}/isort.log
            ${{ env.BACKEND_DIR }}/mypy.log
          if-no-files-found: warn
      
      # Guardar output completo del job
      - name: üíæ Guardar logs completos del job
        if: always()
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "## üìã Resumen del An√°lisis de Calidad" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Verificar errores cr√≠ticos de Flake8
          if [ -f "flake8-critical.log" ] && [ -s "flake8-critical.log" ]; then
            # Contar l√≠neas que empiezan con "app/" y limpiar el resultado
            ERROR_COUNT=$(grep -c "^app/" flake8-critical.log 2>/dev/null | tr -d '\n\r ' || echo "0")
            # Convertir a n√∫mero entero (eliminar cualquier car√°cter no num√©rico)
            ERROR_COUNT=$(echo "$ERROR_COUNT" | grep -oE '[0-9]+' | head -1 || echo "0")
            # Validar que sea un n√∫mero antes de comparar
            if [ -n "$ERROR_COUNT" ] && [ "$ERROR_COUNT" -gt 0 ] 2>/dev/null; then
              echo "### ‚ùå Flake8 - Errores Cr√≠ticos: $ERROR_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              head -30 flake8-critical.log >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ Flake8: Sin errores cr√≠ticos" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚úÖ Flake8: Sin errores cr√≠ticos" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Verificar errores de Isort
          if [ -f "isort.log" ] && [ -s "isort.log" ]; then
            # Isort genera "ERROR:" cuando hay imports incorrectos
            if grep -qi "ERROR:" isort.log 2>/dev/null || grep -qE "^ERROR|Imports are incorrectly sorted" isort.log 2>/dev/null; then
              echo "### ‚ùå Isort - Imports Incorrectos Detectados" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              head -30 isort.log >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "‚ö†Ô∏è Nota: Estos errores fueron corregidos autom√°ticamente por el workflow." >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ Isort: Imports correctos" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚úÖ Isort: Imports correctos" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Formateo: black aplicado" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Tipos: mypy verificado" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÖ Fecha: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "üîó Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìä Logs completos disponibles en los artifacts del job." >> $GITHUB_STEP_SUMMARY

  # ========================================
  # üß™ PRUEBAS BACKEND
  # ========================================
  backend-tests:
    name: üß™ Pruebas Backend
    runs-on: ubuntu-latest
    needs: code-quality
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: üêç Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
          pip install pytest-cov pytest-asyncio httpx
      
      - name: üîß Configurar variables de entorno de prueba
        run: |
          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db" >> $GITHUB_ENV
          echo "SECRET_KEY=test-secret-key-for-ci" >> $GITHUB_ENV
          echo "ENVIRONMENT=testing" >> $GITHUB_ENV
          echo "DEBUG=true" >> $GITHUB_ENV
      
      - name: üóÑÔ∏è Ejecutar migraciones de prueba
        run: |
          cd ${{ env.BACKEND_DIR }}
          alembic upgrade head
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
      
      - name: üß™ Ejecutar pruebas unitarias
        run: |
          cd ${{ env.BACKEND_DIR }}
          pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html
      
      - name: üîó Ejecutar pruebas de integraci√≥n
        run: |
          cd ${{ env.BACKEND_DIR }}
          pytest tests/integration/ -v --cov=app --cov-report=xml --cov-report=html
      
      - name: üìä Subir reporte de cobertura
        uses: codecov/codecov-action@v3
        with:
          file: ${{ env.BACKEND_DIR }}/coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false

  # ========================================
  # üß™ PRUEBAS FRONTEND
  # ========================================
  frontend-tests:
    name: üß™ Pruebas Frontend
    runs-on: ubuntu-latest
    needs: code-quality
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: üì¶ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.FRONTEND_DIR }}/package-lock.json
      
      - name: üì¶ Instalar dependencias frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm ci
      
      - name: üîç Linting con ESLint
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run lint
      
      - name: üé® Formateo con Prettier
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run format:check
      
      - name: üîí Verificaci√≥n de tipos TypeScript
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run type-check
      
      - name: üß™ Ejecutar pruebas unitarias
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:unit
      
      - name: üîó Ejecutar pruebas de integraci√≥n
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:integration
      
      - name: üìä Generar reporte de cobertura
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:coverage
      
      - name: üìä Subir reporte de cobertura frontend
        uses: codecov/codecov-action@v3
        with:
          file: ${{ env.FRONTEND_DIR }}/coverage/lcov.info
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

  # ========================================
  # üèóÔ∏è BUILD Y VERIFICACI√ìN
  # ========================================
  build:
    name: üèóÔ∏è Build y Verificaci√≥n
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: üêç Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
      
      - name: üì¶ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.FRONTEND_DIR }}/package-lock.json
      
      - name: üì¶ Instalar dependencias frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm ci
      
      - name: üèóÔ∏è Build frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run build
      
      - name: üì¶ Verificar build frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          ls -la dist/
          du -sh dist/
      
      - name: üîç Verificar archivos cr√≠ticos
        run: |
          echo "Verificando archivos cr√≠ticos..."
          test -f ${{ env.BACKEND_DIR }}/app/main.py
          test -f ${{ env.FRONTEND_DIR }}/dist/index.html
          echo "‚úÖ Todos los archivos cr√≠ticos presentes"

  # ========================================
  # üöÄ DESPLIEGUE A PRODUCCI√ìN
  # ========================================
  deploy-production:
    name: üöÄ Despliegue a Producci√≥n
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: üöÄ Despliegue a Render
        uses: render-actions/deploy@v1
        with:
          service-id: ${{ secrets.RENDER_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true
          timeout: 600
      
      - name: üîç Verificar health check
        run: |
          echo "Esperando que el servicio est√© disponible..."
          sleep 30
          
          # Intentar health check m√∫ltiples veces
          for i in {1..5}; do
            if curl -f "${{ secrets.RENDER_SERVICE_URL }}/api/v1/health/render"; then
              echo "‚úÖ Health check exitoso"
              break
            else
              echo "‚è≥ Intento $i/5 fall√≥, esperando 30 segundos..."
              sleep 30
            fi
          done
      
      - name: üìä Verificar m√©tricas de despliegue
        run: |
          echo "Verificando m√©tricas del despliegue..."
          curl -s "${{ secrets.RENDER_SERVICE_URL }}/api/v1/health/detailed" | jq '.'
      
      - name: üì± Notificar √©xito
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            ‚úÖ *Despliegue Exitoso*
            üöÄ Sistema de Pr√©stamos y Cobranza
            üìä Branch: ${{ github.ref_name }}
            üë§ Usuario: ${{ github.actor }}
            üîó Commit: ${{ github.sha }}
            üåê URL: ${{ secrets.RENDER_SERVICE_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ========================================
  # üöÄ DESPLIEGUE A STAGING
  # ========================================
  deploy-staging:
    name: üöÄ Despliegue a Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: üöÄ Despliegue a Render Staging
        uses: render-actions/deploy@v1
        with:
          service-id: ${{ secrets.RENDER_STAGING_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true
          timeout: 600
      
      - name: üîç Verificar health check staging
        run: |
          echo "Esperando que el servicio de staging est√© disponible..."
          sleep 30
          
          for i in {1..3}; do
            if curl -f "${{ secrets.RENDER_STAGING_URL }}/api/v1/health/render"; then
              echo "‚úÖ Health check staging exitoso"
              break
            else
              echo "‚è≥ Intento $i/3 fall√≥, esperando 30 segundos..."
              sleep 30
            fi
          done
      
      - name: üì± Notificar staging
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            üß™ *Despliegue Staging Exitoso*
            üöÄ Sistema de Pr√©stamos y Cobranza
            üìä Branch: ${{ github.ref_name }}
            üë§ Usuario: ${{ github.actor }}
            üåê URL: ${{ secrets.RENDER_STAGING_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ========================================
  # üö® NOTIFICACIONES DE FALLO
  # ========================================
  notify-failure:
    name: üö® Notificar Fallo
    runs-on: ubuntu-latest
    needs: [code-quality, backend-tests, frontend-tests, build]
    if: failure()
    
    steps:
      - name: üì± Notificar fallo
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            ‚ùå *Pipeline Fall√≥*
            üöÄ Sistema de Pr√©stamos y Cobranza
            üìä Branch: ${{ github.ref_name }}
            üë§ Usuario: ${{ github.actor }}
            üîó Commit: ${{ github.sha }}
            üìã Job fallido: ${{ github.job }}
            üîó Ver logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
