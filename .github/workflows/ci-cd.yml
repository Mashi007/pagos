name: ğŸš€ CI/CD Pipeline - Sistema de PrÃ©stamos y Cobranza

# Trigger del pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch: # Permite ejecuciÃ³n manual

# Variables globales
env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  BACKEND_DIR: './backend'
  FRONTEND_DIR: './frontend'

jobs:
  # ========================================
  # ğŸ” ANÃLISIS DE CÃ“DIGO Y CALIDAD
  # ========================================
  code-quality:
    name: ğŸ” AnÃ¡lisis de Calidad de CÃ³digo
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Para anÃ¡lisis completo de git
      
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: ğŸ“¦ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
          pip install flake8 black isort mypy
      
      - name: ğŸ” Linting con flake8
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ” Ejecutando flake8 - errores crÃ­ticos..."
          echo "::group::Flake8 - Errores CrÃ­ticos"
          # Ejecutar sin || true para que bloquee en errores crÃ­ticos (sintaxis, funciones no definidas)
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics 2>&1 | tee flake8-critical-output.txt
          FLAKE8_CRITICAL_EXIT=${PIPESTATUS[0]}
          cat flake8-critical-output.txt
          echo "::endgroup::"
          
          echo "ğŸ” Ejecutando flake8 - anÃ¡lisis completo..."
          echo "::group::Flake8 - AnÃ¡lisis Completo"
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          echo "::endgroup::"
          
          # Guardar en archivos para artifacts (siempre generar logs)
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics > flake8-critical.log 2>&1 || true
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics > flake8-full.log 2>&1
          
          # Fallar si hubo errores crÃ­ticos
          if [ $FLAKE8_CRITICAL_EXIT -ne 0 ]; then
            echo "âŒ ERROR: Errores crÃ­ticos de Flake8 detectados (sintaxis, funciones no definidas)."
            echo "Revisa flake8-critical.log para mÃ¡s detalles."
            exit 1
          fi
      
      - name: ğŸ¨ Formateo con black
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ¨ Ejecutando black (verificaciÃ³n)..."
          echo "::group::Black - VerificaciÃ³n de Formato"
          black --check --diff app/ || true
          echo "::endgroup::"
          # TambiÃ©n guardar en archivo para artifacts
          black --check --diff app/ > black.log 2>&1 || true
      
      - name: ğŸ”§ Aplicar correcciones de Black automÃ¡ticamente
        run: |
          cd ${{ env.BACKEND_DIR }}
          # Solo aplicar si el Ãºltimo commit no fue de Black
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
          if ! echo "$LAST_COMMIT_MSG" | grep -qi "black"; then
            # Sincronizar con remoto antes de aplicar cambios para evitar divergencias
            git pull --rebase origin main || echo "âš ï¸ No se pudo hacer pull (puede ser normal si no hay cambios remotos)"
            black app/
            if ! git diff --quiet; then
              git config user.name "GitHub Actions"
              git config user.email "actions@github.com"
              git add app/
              git commit -m "style: Aplicar correcciones automÃ¡ticas de Black [skip ci]"
              git push
              echo "âœ… Correcciones de Black commiteadas y pusheadas"
            else
              echo "âœ… No se requieren correcciones de Black"
            fi
          else
            echo "â­ï¸  Ãšltimo commit fue de Black, saltando correcciÃ³n automÃ¡tica"
          fi
      
      - name: ğŸ“ Ordenamiento de imports con isort
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ“ Verificando orden de imports con isort..."
          echo "::group::Isort - VerificaciÃ³n de Imports"
          # Generar log primero - NO fallar el pipeline aquÃ­
          isort --check-only --diff app/ > isort.log 2>&1 || true
          ISORT_EXIT_CODE=${PIPESTATUS[0]}
          # Mostrar output
          cat isort.log
          echo "::endgroup::"
          # NO hacer exit aquÃ­ - permitir que la correcciÃ³n automÃ¡tica se ejecute
      
      - name: ğŸ”§ Aplicar correcciones de Isort automÃ¡ticamente
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ”§ Aplicando correcciones automÃ¡ticas de Isort..."
          # Solo aplicar si el Ãºltimo commit no fue de Isort
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
          if ! echo "$LAST_COMMIT_MSG" | grep -qi "isort"; then
            # Sincronizar con remoto antes de aplicar cambios para evitar divergencias
            git pull --rebase origin main || echo "âš ï¸ No se pudo hacer pull (puede ser normal si no hay cambios remotos)"
            # Aplicar correcciones
            isort app/
            if ! git diff --quiet; then
              echo "ğŸ“ Correcciones de Isort aplicadas. Haciendo commit..."
              git config user.name "GitHub Actions"
              git config user.email "actions@github.com"
              git add app/
              git commit -m "style: Aplicar correcciones automÃ¡ticas de Isort [skip ci]"
              git push
              echo "âœ… Correcciones de Isort commiteadas y pusheadas"
            else
              echo "âœ… No se requieren correcciones de Isort"
            fi
          else
            echo "â­ï¸  Ãšltimo commit fue de Isort, saltando correcciÃ³n automÃ¡tica"
          fi
      
      - name: ğŸ”’ VerificaciÃ³n de tipos con mypy
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ”’ Ejecutando verificaciÃ³n de tipos con mypy..."
          echo "::group::Mypy - VerificaciÃ³n de Tipos"
          mypy app/ --ignore-missing-imports || true
          echo "::endgroup::"
          # TambiÃ©n guardar en archivo para artifacts
          mypy app/ --ignore-missing-imports > mypy.log 2>&1 || true
      
      # Verificar que los logs existan antes de subirlos
      - name: ğŸ” Verificar logs generados
        if: always()
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "ğŸ” Verificando archivos de log generados..."
          ls -lh *.log 2>/dev/null || echo "âš ï¸ No se encontraron archivos .log"
          echo ""
          echo "ğŸ“‹ Archivos encontrados:"
          for log in flake8-critical.log flake8-full.log black.log isort.log mypy.log; do
            if [ -f "$log" ]; then
              size=$(du -h "$log" | cut -f1)
              lines=$(wc -l < "$log" 2>/dev/null || echo "0")
              echo "  âœ… $log: $size ($lines lÃ­neas)"
            else
              echo "  âš ï¸ $log: NO ENCONTRADO"
            fi
          done
      
      # Guardar TODOS los logs como artifacts descargables
      - name: ğŸ“Š Subir logs de calidad de cÃ³digo
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: code-quality-logs-${{ github.run_number }}
          retention-days: 90
          path: |
            ${{ env.BACKEND_DIR }}/flake8-critical.log
            ${{ env.BACKEND_DIR }}/flake8-full.log
            ${{ env.BACKEND_DIR }}/black.log
            ${{ env.BACKEND_DIR }}/isort.log
            ${{ env.BACKEND_DIR }}/mypy.log
          if-no-files-found: warn
      
      # Guardar output completo del job
      - name: ğŸ’¾ Guardar logs completos del job
        if: always()
        run: |
          cd ${{ env.BACKEND_DIR }}
          echo "## ğŸ“‹ Resumen del AnÃ¡lisis de Calidad" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Verificar errores crÃ­ticos de Flake8
          if [ -f "flake8-critical.log" ] && [ -s "flake8-critical.log" ]; then
            # Contar lÃ­neas que empiezan con "app/" y limpiar el resultado
            ERROR_COUNT=$(grep -c "^app/" flake8-critical.log 2>/dev/null | tr -d '\n\r ' || echo "0")
            # Convertir a nÃºmero entero (eliminar cualquier carÃ¡cter no numÃ©rico)
            ERROR_COUNT=$(echo "$ERROR_COUNT" | grep -oE '[0-9]+' | head -1 || echo "0")
            # Validar que sea un nÃºmero antes de comparar
            if [ -n "$ERROR_COUNT" ] && [ "$ERROR_COUNT" -gt 0 ] 2>/dev/null; then
              echo "### âŒ Flake8 - Errores CrÃ­ticos: $ERROR_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              head -30 flake8-critical.log >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… Flake8: Sin errores crÃ­ticos" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âœ… Flake8: Sin errores crÃ­ticos" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Verificar errores de Isort
          if [ -f "isort.log" ] && [ -s "isort.log" ]; then
            # Isort genera "ERROR:" cuando hay imports incorrectos
            if grep -qi "ERROR:" isort.log 2>/dev/null || grep -qE "^ERROR|Imports are incorrectly sorted" isort.log 2>/dev/null; then
              echo "### âŒ Isort - Imports Incorrectos Detectados" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              head -30 isort.log >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "âš ï¸ Nota: Estos errores fueron corregidos automÃ¡ticamente por el workflow." >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… Isort: Imports correctos" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âœ… Isort: Imports correctos" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Formateo: black aplicado" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Tipos: mypy verificado" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ“… Fecha: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ”— Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ“Š Logs completos disponibles en los artifacts del job." >> $GITHUB_STEP_SUMMARY

  # ========================================
  # ğŸ§ª PRUEBAS BACKEND
  # ========================================
  backend-tests:
    name: ğŸ§ª Pruebas Backend
    runs-on: ubuntu-latest
    needs: code-quality
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: ğŸ“¦ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
          pip install pytest-cov pytest-asyncio httpx
      
      - name: ğŸ”§ Configurar variables de entorno de prueba
        run: |
          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db" >> $GITHUB_ENV
          echo "SECRET_KEY=test-secret-key-for-ci" >> $GITHUB_ENV
          echo "ENVIRONMENT=testing" >> $GITHUB_ENV
          echo "DEBUG=true" >> $GITHUB_ENV
      
      - name: ğŸ—„ï¸ Ejecutar migraciones de prueba
        run: |
          cd ${{ env.BACKEND_DIR }}
          alembic upgrade head
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
      
      - name: ğŸ§ª Ejecutar pruebas unitarias
        run: |
          cd ${{ env.BACKEND_DIR }}
          pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html
      
      - name: ğŸ”— Ejecutar pruebas de integraciÃ³n
        run: |
          cd ${{ env.BACKEND_DIR }}
          pytest tests/integration/ -v --cov=app --cov-report=xml --cov-report=html
      
      - name: ğŸ“Š Subir reporte de cobertura
        uses: codecov/codecov-action@v3
        with:
          file: ${{ env.BACKEND_DIR }}/coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false

  # ========================================
  # ğŸ§ª PRUEBAS FRONTEND
  # ========================================
  frontend-tests:
    name: ğŸ§ª Pruebas Frontend
    runs-on: ubuntu-latest
    needs: code-quality
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ğŸ“¦ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.FRONTEND_DIR }}/package-lock.json
      
      - name: ğŸ“¦ Instalar dependencias frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm ci
      
      - name: ğŸ” Linting con ESLint
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run lint
      
      - name: ğŸ¨ Formateo con Prettier
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run format:check
      
      - name: ğŸ”’ VerificaciÃ³n de tipos TypeScript
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run type-check
      
      - name: ğŸ§ª Ejecutar pruebas unitarias
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:unit
      
      - name: ğŸ”— Ejecutar pruebas de integraciÃ³n
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:integration
      
      - name: ğŸ“Š Generar reporte de cobertura
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run test:coverage
      
      - name: ğŸ“Š Subir reporte de cobertura frontend
        uses: codecov/codecov-action@v3
        with:
          file: ${{ env.FRONTEND_DIR }}/coverage/lcov.info
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

  # ========================================
  # ğŸ—ï¸ BUILD Y VERIFICACIÃ“N
  # ========================================
  build:
    name: ğŸ—ï¸ Build y VerificaciÃ³n
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: ğŸ“¦ Instalar dependencias backend
        run: |
          cd ${{ env.BACKEND_DIR }}
          pip install -r requirements.txt
      
      - name: ğŸ“¦ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.FRONTEND_DIR }}/package-lock.json
      
      - name: ğŸ“¦ Instalar dependencias frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm ci
      
      - name: ğŸ—ï¸ Build frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm run build
      
      - name: ğŸ“¦ Verificar build frontend
        run: |
          cd ${{ env.FRONTEND_DIR }}
          ls -la dist/
          du -sh dist/
      
      - name: ğŸ” Verificar archivos crÃ­ticos
        run: |
          echo "Verificando archivos crÃ­ticos..."
          test -f ${{ env.BACKEND_DIR }}/app/main.py
          test -f ${{ env.FRONTEND_DIR }}/dist/index.html
          echo "âœ… Todos los archivos crÃ­ticos presentes"

  # ========================================
  # ğŸš€ DESPLIEGUE A PRODUCCIÃ“N
  # ========================================
  deploy-production:
    name: ğŸš€ Despliegue a ProducciÃ³n
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ğŸš€ Despliegue a Render
        uses: render-actions/deploy@v1
        with:
          service-id: ${{ secrets.RENDER_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true
          timeout: 600
      
      - name: ğŸ” Verificar health check
        run: |
          echo "Esperando que el servicio estÃ© disponible..."
          sleep 30
          
          # Intentar health check mÃºltiples veces
          for i in {1..5}; do
            if curl -f "${{ secrets.RENDER_SERVICE_URL }}/api/v1/health/render"; then
              echo "âœ… Health check exitoso"
              break
            else
              echo "â³ Intento $i/5 fallÃ³, esperando 30 segundos..."
              sleep 30
            fi
          done
      
      - name: ğŸ“Š Verificar mÃ©tricas de despliegue
        run: |
          echo "Verificando mÃ©tricas del despliegue..."
          curl -s "${{ secrets.RENDER_SERVICE_URL }}/api/v1/health/detailed" | jq '.'
      
      - name: ğŸ“± Notificar Ã©xito
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            âœ… *Despliegue Exitoso*
            ğŸš€ Sistema de PrÃ©stamos y Cobranza
            ğŸ“Š Branch: ${{ github.ref_name }}
            ğŸ‘¤ Usuario: ${{ github.actor }}
            ğŸ”— Commit: ${{ github.sha }}
            ğŸŒ URL: ${{ secrets.RENDER_SERVICE_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ========================================
  # ğŸš€ DESPLIEGUE A STAGING
  # ========================================
  deploy-staging:
    name: ğŸš€ Despliegue a Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ğŸš€ Despliegue a Render Staging
        uses: render-actions/deploy@v1
        with:
          service-id: ${{ secrets.RENDER_STAGING_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true
          timeout: 600
      
      - name: ğŸ” Verificar health check staging
        run: |
          echo "Esperando que el servicio de staging estÃ© disponible..."
          sleep 30
          
          for i in {1..3}; do
            if curl -f "${{ secrets.RENDER_STAGING_URL }}/api/v1/health/render"; then
              echo "âœ… Health check staging exitoso"
              break
            else
              echo "â³ Intento $i/3 fallÃ³, esperando 30 segundos..."
              sleep 30
            fi
          done
      
      - name: ğŸ“± Notificar staging
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            ğŸ§ª *Despliegue Staging Exitoso*
            ğŸš€ Sistema de PrÃ©stamos y Cobranza
            ğŸ“Š Branch: ${{ github.ref_name }}
            ğŸ‘¤ Usuario: ${{ github.actor }}
            ğŸŒ URL: ${{ secrets.RENDER_STAGING_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ========================================
  # ğŸš¨ NOTIFICACIONES DE FALLO
  # ========================================
  notify-failure:
    name: ğŸš¨ Notificar Fallo
    runs-on: ubuntu-latest
    needs: [code-quality, backend-tests, frontend-tests, build]
    if: failure()
    
    steps:
      - name: ğŸ“± Notificar fallo
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            âŒ *Pipeline FallÃ³*
            ğŸš€ Sistema de PrÃ©stamos y Cobranza
            ğŸ“Š Branch: ${{ github.ref_name }}
            ğŸ‘¤ Usuario: ${{ github.actor }}
            ğŸ”— Commit: ${{ github.sha }}
            ğŸ“‹ Job fallido: ${{ github.job }}
            ğŸ”— Ver logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
