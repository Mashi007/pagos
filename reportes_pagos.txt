@router.get("/pagos")
def get_reporte_pagos(
    db: Session = Depends(get_db),
    fecha_inicio: str = Query(..., description="YYYY-MM-DD"),
    fecha_fin: str = Query(..., description="YYYY-MM-DD"),
):
    """Reporte de pagos en un rango de fechas. Datos reales desde BD."""
    fi = _parse_fecha(fecha_inicio)
    ff = _parse_fecha(fecha_fin)
    if fi > ff:
        fi, ff = ff, fi
    # Solo clientes ACTIVOS
    total_pagos = _safe_float(
        db.scalar(
            select(func.coalesce(func.sum(Cuota.monto), 0))
            .select_from(Cuota)
            .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.estado == "APROBADO",
                Cuota.fecha_pago.isnot(None),
                func.date(Cuota.fecha_pago) >= fi,
                func.date(Cuota.fecha_pago) <= ff,
            )
        )
        or 0
    )
    cantidad_pagos = db.scalar(
        select(func.count())
        .select_from(Cuota)
        .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
        .join(Cliente, Prestamo.cliente_id == Cliente.id)
        .where(
            Cliente.estado == "ACTIVO",
            Prestamo.estado == "APROBADO",
            Cuota.fecha_pago.isnot(None),
            func.date(Cuota.fecha_pago) >= fi,
            func.date(Cuota.fecha_pago) <= ff,
        )
    ) or 0
    pagos_por_dia = (
        db.execute(
            select(func.date(Cuota.fecha_pago).label("fecha"), func.count().label("cantidad"), func.sum(Cuota.monto).label("monto"))
            .select_from(Cuota)
            .join(Prestamo, Cuota.prestamo_id == Prestamo.id)
            .join(Cliente, Prestamo.cliente_id == Cliente.id)
            .where(
                Cliente.estado == "ACTIVO",
                Prestamo.estado == "APROBADO",
                Cuota.fecha_pago.isnot(None),
                func.date(Cuota.fecha_pago) >= fi,
                func.date(Cuota.fecha_pago) <= ff,
            )
            .group_by(func.date(Cuota.fecha_pago))
            .order_by(func.date(Cuota.fecha_pago))
        )
    ).fetchall()
    return {
        "fecha_inicio": fi.isoformat(),
        "fecha_fin": ff.isoformat(),
        "total_pagos": total_pagos,
        "cantidad_pagos": cantidad_pagos,
        "pagos_por_metodo": [],
        "pagos_por_dia": [
            {"fecha": str(r.fecha), "cantidad": r.cantidad, "monto": _safe_float(r.monto)}
            for r in pagos_por_dia
        ],
    }


def _pagos_por_dia_periodos(db: Session, periodos: List[tuple]) -> dict:
    """Genera datos pagos por dÃ­a para lista de (aÃ±o, mes)."""
    resultado: dict = {"meses": []}
    for (aÃ±o, mes) in periodos:
        inicio = date(aÃ±o, mes, 1)
        _, ultimo = calendar.monthrange(aÃ±o, mes)
        fin = date(aÃ±o, mes, ultimo)

        rows = db.execute(
            select(
                func.extract("day", Pago.fecha_pago).label("dia"),
                func.count(Pago.id).label("cantidad_pagos"),
                func.count(func.distinct(Pago.cedula_cliente)).label("cantidad_cedulas"),
                func.coalesce(func.sum(Pago.monto_pagado), 0).label("monto_total"),
            )
            .select_from(Pago)
            .where(
                func.date(Pago.fecha_pago) >= inicio,
                func.date(Pago.fecha_pago) <= fin,
            )
            .group_by(func.extract("day", Pago.fecha_pago))
            .order_by(func.extract("day", Pago.fecha_pago))
        ).fetchall()

        por_dia: dict = {}
        for r in rows:
            d = int(r.dia) if r.dia is not None else 0
            por_dia[d] = {
                "cantidad_pagos": r.cantidad_pagos or 0,
                "cantidad_cedulas": r.cantidad_cedulas or 0,
                "monto_total": round(_safe_float(r.monto_total), 2),
            }

        items: List[dict] = []
        for d in range(1, ultimo + 1):
            data = por_dia.get(d, {"cantidad_pagos": 0, "cantidad_cedulas": 0, "monto_total": 0})
            items.append({
                "dia": d,
                "cantidad_pagos": data["cantidad_pagos"],
                "cantidad_cedulas": data["cantidad_cedulas"],
                "monto_total": data["monto_total"],
            })

        resultado["meses"].append({
            "mes": mes,
            "aÃ±o": aÃ±o,
            "label": f"{mes:02d}/{aÃ±o}",
            "items": items,
        })

    return resultado


@router.get("/pagos/por-dia-mes")
def get_pagos_por_dia_mes(
    db: Session = Depends(get_db),
    meses: int = Query(12, ge=1, le=24, description="Cantidad de meses hacia atrÃ¡s"),
    aÃ±os: Optional[str] = Query(None, description="AÃ±os separados por coma"),
    meses_list: Optional[str] = Query(None, description="Meses 1-12 separados por coma"),
):
    """Pagos por dÃ­a del mes: una pestaÃ±a por mes (MM/YYYY). Por dÃ­a: cantidad pagos, cantidad cÃ©dulas, monto ($)."""
    periodos = _periodos_desde_filtros(aÃ±os, meses_list, meses)
    return _pagos_por_dia_periodos(db, periodos)


@router.get("/pagos/por-mes")
def get_pagos_por_mes(
    db: Session = Depends(get_db),
    meses: int = Query(12, ge=1, le=24, description="Cantidad de meses hacia atrÃ¡s"),
):
    """Pagos agrupados por mes/aÃ±o. Cada mes tiene lista de pagos: Fecha, id prÃ©stamo, cÃ©dula, nombre, monto, documento. Orden descendente por fecha."""
    hoy = date.today()
    resultado: dict = {"meses": []}

    for i in range(meses):
        aÃ±o = hoy.year
        mes = hoy.month - i
        while mes <= 0:
            mes += 12
            aÃ±o -= 1
        inicio = date(aÃ±o, mes, 1)
        _, ultimo = calendar.monthrange(aÃ±o, mes)
        fin = date(aÃ±o, mes, ultimo)

        q = (
            select(
                Pago.id,
                Pago.fecha_pago,
                Pago.prestamo_id,
                Pago.cedula_cliente,
                Pago.monto_pagado,
                Pago.numero_documento,
                func.coalesce(Prestamo.nombres, Cliente.nombres).label("nombres"),
            )
            .select_from(Pago)
            .outerjoin(Prestamo, Pago.prestamo_id == Prestamo.id)
            .outerjoin(Cliente, Pago.cedula_cliente == Cliente.cedula)
            .where(
                func.date(Pago.fecha_pago) >= inicio,
                func.date(Pago.fecha_pago) <= fin,
            )
            .order_by(Pago.fecha_pago.desc())
        )
        rows = db.execute(q).fetchall()

        items = []
        for r in rows:
            fp = r.fecha_pago
            fecha_str = fp.date().isoformat() if hasattr(fp, "date") else (fp.isoformat()[:10] if fp else None)
            items.append({
                "pago_id": r.id,
                "fecha": fecha_str,
                "prestamo_id": r.prestamo_id,
                "cedula": r.cedula_cliente or "",
                "nombre": (r.nombres or "").strip(),
                "monto_pago": _safe_float(r.monto_pagado),
                "documento": r.numero_documento or "",
            })

        resultado["meses"].append({
            "mes": mes,
            "aÃ±o": aÃ±o,
            "label": f"{mes:02d}/{aÃ±o}",
            "items": items,
        })

    return resultado


def _generar_excel_pagos_por_mes(data_por_mes: dict) -> bytes:
    """Genera Excel con una pestaÃ±a por mes (MM/YYYY). Columnas: DÃ­a | Cantidad pagos | Cantidad cÃ©dulas | Monto ($)."""
    import openpyxl
    from datetime import datetime
    
    wb = openpyxl.Workbook()
    meses_data = data_por_mes.get("meses", [])

    # Diccionario de meses en espaÃ±ol
    meses_es = {
        1: "Enero", 2: "Febrero", 3: "Marzo", 4: "Abril", 5: "Mayo", 6: "Junio",
        7: "Julio", 8: "Agosto", 9: "Septiembre", 10: "Octubre", 11: "Noviembre", 12: "Diciembre"
    }

    for idx, mes_data in enumerate(meses_data):
        mes = mes_data.get("mes", 1)
        aÃ±o = mes_data.get("aÃ±o", datetime.now().year)
        mes_nombre = meses_es.get(mes, "")
        label = mes_data.get("label", f"{mes:02d}/{aÃ±o}")
        sheet_name = f"{mes_nombre} {aÃ±o}"[:31]
        
        if idx == 0:
            ws = wb.active
            ws.title = sheet_name
        else:
            ws = wb.create_sheet(title=sheet_name)

        ws.append(["Reporte de Pagos", label])
        ws.append([])
        
        # Calcular totales
        items = mes_data.get("items", [])
        total_pagos = sum(item.get("cantidad_pagos", 0) for item in items)
        total_cedulas = sum(item.get("cantidad_cedulas", 0) for item in items)
        total_monto = sum(item.get("monto_total", 0) for item in items)
        
        # Agregar fila de totales
        ws.append([
            f"Total pagos: {total_pagos} | Total cÃ©dulas: {total_cedulas} | Total monto: ${total_monto:.2f}"
        ])
        ws.append([])
        
        ws.append(["DÃ­a", "Cantidad de pagos", "Cantidad de cÃ©dulas", "Monto ($)"])
        for item in items:
            ws.append([
                item.get("dia", 0),
                item.get("cantidad_pagos", 0),
                item.get("cantidad_cedulas", 0),
                item.get("monto_total", 0),
            ])

    buf = io.BytesIO()
    wb.save(buf)
    return buf.getvalue()


def _generar_excel_pagos(data: dict) -> bytes:
    """Excel clÃ¡sico de pagos por rango de fechas."""
    import openpyxl
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Pagos"
    ws.append(["Reporte de Pagos", data.get("fecha_inicio", ""), "a", data.get("fecha_fin", "")])
    ws.append([])
    ws.append(["Total pagos", data.get("total_pagos", 0)])
    ws.append(["Cantidad de pagos", data.get("cantidad_pagos", 0)])
    ws.append([])
    ws.append(["Fecha", "Cantidad", "Monto"])
    for r in data.get("pagos_por_dia", []):
        ws.append([r.get("fecha", ""), r.get("cantidad", 0), r.get("monto", 0)])
    buf = io.BytesIO()
    wb.save(buf)
    return buf.getvalue()


def _generar_pdf_pagos(data: dict) -> bytes:
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet
    buf = io.BytesIO()
    doc = SimpleDocTemplate(buf, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []
    story.append(Paragraph("Reporte de Pagos", styles["Title"]))
    story.append(Paragraph(f"PerÃ­odo: {data.get('fecha_inicio', '')} a {data.get('fecha_fin', '')}", styles["Normal"]))
    story.append(Spacer(1, 12))
    resumen = [
        ["Total pagos (monto)", str(data.get("total_pagos", 0))],
        ["Cantidad de pagos", str(data.get("cantidad_pagos", 0))],
    ]
    t = Table(resumen)
    t.setStyle(TableStyle([("BACKGROUND", (0, 0), (-1, 0), "#e0e0e0"), ("GRID", (0, 0), (-1, -1), 0.5, "#ccc")]))
    story.append(t)
    pagos_por_dia = data.get("pagos_por_dia", [])
    if pagos_por_dia:
        story.append(Spacer(1, 12))
        story.append(Paragraph("Pagos por dÃ­a", styles["Heading2"]))
        rows = [["Fecha", "Cantidad", "Monto"]]
        for r in pagos_por_dia:
            rows.append([r.get("fecha", ""), str(r.get("cantidad", 0)), str(r.get("monto", 0))])
        t2 = Table(rows)
        t2.setStyle(TableStyle([("BACKGROUND", (0, 0), (-1, 0), "#e0e0e0"), ("GRID", (0, 0), (-1, -1), 0.5, "#ccc")]))
        story.append(t2)
    doc.build(story)
    return buf.getvalue()


@router.get("/exportar/pagos")
def exportar_pagos(
    db: Session = Depends(get_db),
    formato: str = Query("excel", pattern="^(excel|pdf)$"),
    fecha_inicio: Optional[str] = Query(None),
    fecha_fin: Optional[str] = Query(None),
    meses: int = Query(12, ge=1, le=24, description="Para Excel: cantidad de meses (una pestaÃ±a por mes)"),
    aÃ±os: Optional[str] = Query(None, description="AÃ±os separados por coma"),
    meses_list: Optional[str] = Query(None, description="Meses 1-12 separados por coma"),
):
    """Exporta reporte de pagos. Excel: una pestaÃ±a por mes (MM/YYYY), columnas DÃ­a | Cantidad pagos | Cantidad cÃ©dulas | Monto ($).
    PDF: requiere fecha_inicio y fecha_fin."""
    if formato == "excel":
        data_por_mes = get_pagos_por_dia_mes(db=db, meses=meses, aÃ±os=aÃ±os, meses_list=meses_list)
        content = _generar_excel_pagos_por_mes(data_por_mes)
        hoy_str = date.today().isoformat()
        return Response(
            content=content,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename=reporte_pagos_{hoy_str}.xlsx"},
        )
    fi = _parse_fecha(fecha_inicio or date.today().isoformat())
    ff = _parse_fecha(fecha_fin or date.today().isoformat())
    if fi > ff:
        fi, ff = ff, fi
    data = get_reporte_pagos(db=db, fecha_inicio=fi.isoformat(), fecha_fin=ff.isoformat())
    content = _generar_pdf_pagos(data)
    return Response(content=content, media_type="application/pdf", headers={"Content-Disposition": f"attachment; filename=reporte_pagos_{fi.isoformat()}_{ff.isoformat()}.pdf"})


