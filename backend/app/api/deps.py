# backend/app/api/deps.py"""Dependencias comunes para los endpointsIncluye autenticaci√≥n, permisos, y paginaci√≥n"""import loggingfrom typing import Optionalfrom fastapi import Depends, HTTPException, statusfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearerfrom jose import JWTErrorfrom sqlalchemy.orm import Sessionfrom app.core.permissions_simple import Permission, get_user_permissionsfrom app.core.security import decode_tokenfrom app.db.session import get_dbfrom app.models.user import User# Security scheme para JWTsecurity = HTTPBearer()def get_current_user(    db: Session = Depends(get_db),    credentials: HTTPAuthorizationCredentials = Depends(security),) -> User:    """    Obtiene el usuario actual desde el token JWT    Args:        db: Sesi√≥n de base de datos        credentials: Credenciales HTTP Bearer (JWT)    Returns:        Usuario actual    Raises:        HTTPException: Si el token es inv√°lido o el usuario no existe    """    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail="No se pudieron validar las credenciales",        headers={"WWW-Authenticate": "Bearer"},    )    # Logging detallado para diagn√≥stico    logger = logging.getLogger(__name__)    try:        token = credentials.credentials        logger.info(f"üîç Validando token JWT - Longitud: {len(token)}")        payload = decode_token(token)        logger.info(            f"‚úÖ Token decodificado exitosamente - "            f"Payload keys: {list(payload.keys())}"        )        # Verificar que sea un access token        if payload.get("type") != "access":            logger.warning(f"‚ùå Token tipo incorrecto: {payload.get('type')}")            raise credentials_exception        user_id: str = payload.get("sub")        if user_id is None:            logger.warning("‚ùå Token sin user_id (sub)")            raise credentials_exception        logger.info(f"üîç Buscando usuario con ID: {user_id}")    except JWTError as e:        logger.error(f"‚ùå Error decodificando JWT: {e}")        raise credentials_exception    # Buscar usuario en BD    user = db.query(User).filter(User.id == int(user_id)).first()    if user is None:        logger.error(f"‚ùå Usuario no encontrado en BD - ID: {user_id}")        raise HTTPException(            status_code=status.HTTP_404_NOT_FOUND,            detail="Usuario no encontrado",        )    if not user.is_active:        logger.warning(f"‚ö†Ô∏è Usuario inactivo - Email: {user.email}")        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST, detail="Usuario inactivo"        )    logger.info(f"‚úÖ Usuario autenticado exitosamente - Email: {user.email}")    return userdef get_current_active_user(    current_user: User = Depends(get_current_user),) -> User:    """    Obtiene el usuario actual y verifica que est√© activo    Args:        current_user: Usuario actual    Returns:        Usuario activo    Raises:        HTTPException: Si el usuario est√° inactivo    """    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST, detail="Usuario inactivo"        )    return current_userdef require_role(require_admin: bool = True):    """    Dependency para requerir rol de administrador    Args:        require_admin: Si True, requiere admin.                      Si False, cualquier usuario activo.    Returns:        Funci√≥n de dependencia    Usage:        @app.get("/admin", dependencies=[Depends(require_role(True))])    """    def role_checker(current_user: User = Depends(get_current_user)) -> User:        if require_admin and not current_user.is_admin:            raise HTTPException(                status_code=status.HTTP_403_FORBIDDEN,                detail="Se requiere rol de administrador",            )        return current_user    return role_checkerdef require_permission(*required_permissions: Permission):    """    Dependency para requerir uno o m√°s permisos espec√≠ficos    Args:        required_permissions: Permisos requeridos    Returns:        Funci√≥n de dependencia    Usage:        @app.post("/clientes",                 dependencies=[Depends    (require_permission(Permission.CLIENTE_CREATE))])    """    def permission_checker(        current_user: User = Depends(get_current_user),    ) -> User:        # Obtener permisos del usuario basado en is_admin        user_permissions = get_user_permissions(current_user.is_admin)        # Verificar cada permiso requerido        for perm in required_permissions:            if perm not in user_permissions:                raise HTTPException(                    status_code=status.HTTP_403_FORBIDDEN,                    detail=f"Permiso requerido: {perm.value}",                )        return current_user    return permission_checkerdef get_admin_user(current_user: User = Depends(get_current_user)) -> User:    """    Dependency para endpoints que requieren usuario administrador    Returns:        Usuario con is_admin = True    """    if not current_user.is_admin:  # Cambio clave: rol ‚Üí is_admin        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Solo los administradores pueden acceder a este recurso",        )    return current_user# Dependency para paginaci√≥nclass PaginationParams:    """Par√°metros de paginaci√≥n comunes"""    def __init__(        self,        page: int = 1,        page_size: int = 10,        skip: Optional[int] = None,        limit: Optional[int] = None,    ):        # Validaciones        if page < 1:            page = 1        if page_size < 1:            page_size = 10        if page_size > 100:            page_size = 100        self.page = page        self.page_size = page_size        self.skip = skip if skip is not None else (page - 1) * page_size        self.limit = limit if limit is not None else page_sizedef get_pagination_params(    page: int = 1, page_size: int = 10) -> PaginationParams:    """    Dependency para obtener par√°metros de paginaci√≥n    Args:        page: N√∫mero de p√°gina (default: 1)        page_size: Tama√±o de p√°gina (default: 10, max: 100)    Returns:        Par√°metros de paginaci√≥n    Usage:        @app.get("/items")        def get_items(            pagination: PaginationParams = Depends(get_pagination_params)        ):            skip = pagination.skip            limit = pagination.limit    """    return PaginationParams(page=page, page_size=page_size)