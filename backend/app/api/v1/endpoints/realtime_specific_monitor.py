"""Sistema de Monitoreo en Tiempo Real Espec√≠ficoMonitorea espec√≠ficamente los momentos cuando ocurren fallos 401 intermitentes"""\nimport logging\nimport threading\nimport time\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE MONITOREO EN TIEMPO REAL ESPEC√çFICO# ============================================\nclass RealTimeSpecificMonitor:\n    """Monitor espec√≠fico para fallos 401 intermitentes"""    \ndef __init__(self):\n        self.active_monitoring = False        self.monitoring_sessions = {}  # Sesiones de monitoreo activas        self.real_time_events = deque(maxlen=1000)  # Eventos en tiempo real        self.failure_moments = deque(            maxlen=100        )  # Momentos espec√≠ficos de fallo        self.success_moments = deque(            maxlen=100        )  # Momentos espec√≠ficos de √©xito        self.lock = threading.Lock()    \ndef start_specific_monitoring(        self, session_id:\n str, target_endpoints:\n List[str] = None    ) -> Dict[str, Any]:\n        """Iniciar monitoreo espec√≠fico"""        with self.lock:\n            monitoring_session = {                "session_id":\n session_id,                "start_time":\n datetime.now(),                "target_endpoints":\n target_endpoints or [],                "status":\n "active",                "events_captured":\n 0,                "failures_captured":\n 0,                "successes_captured":\n 0,            }            self.monitoring_sessions[session_id] = monitoring_session            self.active_monitoring = True            logger.info(f"üîç Monitoreo espec√≠fico iniciado:\n {session_id}")            return monitoring_session    \ndef stop_specific_monitoring(self, session_id:\n str) -> Dict[str, Any]:\n        """Detener monitoreo espec√≠fico"""        with self.lock:\n            if session_id not in self.monitoring_sessions:\n                return {"error":\n "Sesi√≥n no encontrada"}            session = self.monitoring_sessions[session_id]            session["status"] = "stopped"            session["end_time"] = datetime.now()            session["duration_seconds"] = (                session["end_time"] - session["start_time"]            ).total_seconds()            # Si no hay m√°s sesiones activas, detener monitoreo global            active_sessions = [                s                for s in self.monitoring_sessions.values()                if s["status"] == "active"            ]            if not active_sessions:\n                self.active_monitoring = False            logger.info(f"‚èπÔ∏è Monitoreo espec√≠fico detenido:\n {session_id}")            return session    \ndef capture_auth_event(self, event_type:\n str, event_data:\n Dict[str, Any]):\n        """Capturar evento de autenticaci√≥n en tiempo real"""        if not self.active_monitoring:\n            return        with self.lock:\n            event = {                "event_id":\n (                    f"rt_{len(self.real_time_events)}_{int(time.time())}"                ),                "event_type":\n event_type,                "timestamp":\n datetime.now(),                "data":\n event_data,                "session_context":\n self._get_session_context(),            }            self.real_time_events.append(event)            # Actualizar contadores de sesiones activas            for session in self.monitoring_sessions.values():\n                if session["status"] == "active":\n                    session["events_captured"] += 1                    if event_type in [                        "auth_failure",                        "token_expired",                        "validation_failed",                    ]:\n                        session["failures_captured"] += 1                        self.failure_moments.append(event)                    elif event_type in [                        "auth_success",                        "token_validated",                        "user_authenticated",                    ]:\n                        session["successes_captured"] += 1                        self.success_moments.append(event)            logger.debug(f"üì° Evento capturado:\n {event_type}")    \ndef _get_session_context(self) -> Dict[str, Any]:\n        """Obtener contexto de sesiones activas"""        active_sessions = [            s            for s in self.monitoring_sessions.values()            if s["status"] == "active"        ]        return {            "active_sessions_count":\n len(active_sessions),            "session_ids":\n [s["session_id"] for s in active_sessions],            "total_events_captured":\n sum(                s["events_captured"] for s in active_sessions            ),        }    \ndef analyze_failure_moments(self) -> Dict[str, Any]:\n        """Analizar momentos espec√≠ficos de fallo"""        with self.lock:\n            if not self.failure_moments:\n                return {"error":\n "No hay momentos de fallo capturados"}            analysis = {                "timestamp":\n datetime.now().isoformat(),                "total_failure_moments":\n len(self.failure_moments),                "failure_patterns":\n self._analyze_failure_patterns(),                "timing_analysis":\n self._analyze_failure_timing(),                "context_analysis":\n self._analyze_failure_context(),                "correlation_analysis":\n self._analyze_failure_correlations(),            }            return analysis    \ndef _analyze_failure_patterns(self) -> Dict[str, Any]:\n        """Analizar patrones en momentos de fallo"""        failure_types = defaultdict(int)        endpoints = defaultdict(int)        error_messages = defaultdict(int)        for moment in self.failure_moments:\n            failure_types[moment["event_type"]] += 1            endpoint = moment["data"].get("endpoint", "unknown")            endpoints[endpoint] += 1            error_msg = moment["data"].get("error_message", "unknown")            error_messages[error_msg] += 1        return {            "failure_type_distribution":\n dict(failure_types),            "endpoint_distribution":\n dict(endpoints),            "error_message_distribution":\n dict(error_messages),        }    \ndef _analyze_failure_timing(self) -> Dict[str, Any]:\n        """Analizar timing de momentos de fallo"""        if len(self.failure_moments) < 2:\n            return {"error":\n "Datos insuficientes para an√°lisis de timing"}        timestamps = [moment["timestamp"] for moment in self.failure_moments]        timestamps.sort()        intervals = []        for i in range(1, len(timestamps)):\n            interval = (timestamps[i] - timestamps[i - 1]).total_seconds()            intervals.append(interval)        return {            "failure_intervals_seconds":\n intervals,            "avg_interval_seconds":\n (                sum(intervals) / len(intervals) if intervals else 0            ),            "min_interval_seconds":\n min(intervals) if intervals else 0,            "max_interval_seconds":\n max(intervals) if intervals else 0,            "first_failure":\n timestamps[0].isoformat(),            "last_failure":\n timestamps[-1].isoformat(),        }    \ndef _analyze_failure_context(self) -> Dict[str, Any]:\n        """Analizar contexto de momentos de fallo"""        contexts = []        for moment in self.failure_moments:\n            context = moment.get("session_context", {})            contexts.append(context)        if not contexts:\n            return {"error":\n "No hay contexto disponible"}        return {            "avg_active_sessions":\n (                sum(c.get("active_sessions_count", 0) for c in contexts)                / len(contexts)            ),            "total_events_during_failures":\n sum(                c.get("total_events_captured", 0) for c in contexts            ),            "context_samples":\n contexts[-5:\n],  # √öltimos 5 contextos        }    \ndef _analyze_failure_correlations(self) -> Dict[str, Any]:\n        """Analizar correlaciones entre fallos y √©xitos"""        if not self.success_moments:\n            return {"error":\n "No hay momentos de √©xito para correlaci√≥n"}        # Buscar patrones de alternancia entre √©xito y fallo        all_moments = []        for moment in self.failure_moments:\n            all_moments.append({**moment, "outcome":\n "failure"})        for moment in self.success_moments:\n            all_moments.append({**moment, "outcome":\n "success"})        all_moments.sort(key=lambda x:\n x["timestamp"])        # Analizar transiciones        transitions = []        for i in range(len(all_moments) - 1):\n            current = all_moments[i]["outcome"]            next_outcome = all_moments[i + 1]["outcome"]            if current != next_outcome:\n                transitions.append(                    {                        "from":\n current,                        "to":\n next_outcome,                        "time_diff_seconds":\n (                            (                                all_moments[i + 1]["timestamp"]                                - all_moments[i]["timestamp"]                            ).total_seconds()                        ),                    }                )        return {            "total_transitions":\n len(transitions),            "failure_to_success_transitions":\n len(                [                    t                    for t in transitions                    if t["from"] == "failure" and t["to"] == "success"                ]            ),            "success_to_failure_transitions":\n len(                [                    t                    for t in transitions                    if t["from"] == "success" and t["to"] == "failure"                ]            ),            "avg_transition_time_seconds":\n (                sum(t["time_diff_seconds"] for t in transitions)                / len(transitions)                if transitions                else 0            ),        }    \ndef get_real_time_status(self) -> Dict[str, Any]:\n        """Obtener estado del monitoreo en tiempo real"""        with self.lock:\n            active_sessions = [                s                for s in self.monitoring_sessions.values()                if s["status"] == "active"            ]            return {                "timestamp":\n datetime.now().isoformat(),                "monitoring_active":\n self.active_monitoring,                "active_sessions_count":\n len(active_sessions),                "total_events_captured":\n len(self.real_time_events),                "failure_moments_captured":\n len(self.failure_moments),                "success_moments_captured":\n len(self.success_moments),                "active_sessions":\n [                    {                        "session_id":\n s["session_id"],                        "start_time":\n s["start_time"].isoformat(),                        "events_captured":\n s["events_captured"],                        "failures_captured":\n s["failures_captured"],                        "successes_captured":\n s["successes_captured"],                    }                    for s in active_sessions                ],            }    \ndef get_monitoring_session_details(        self, session_id:\n str    ) -> Dict[str, Any]:\n        """Obtener detalles de sesi√≥n de monitoreo espec√≠fica"""        with self.lock:\n            if session_id not in self.monitoring_sessions:\n                return {"error":\n "Sesi√≥n no encontrada"}            session = self.monitoring_sessions[session_id]            # Filtrar eventos de esta sesi√≥n            session_events = []            for event in self.real_time_events:\n                if session["start_time"] <= event["timestamp"]:\n                    if session["status"] == "stopped" and hasattr(                        session, "end_time"                    ):\n                        if event["timestamp"] <= session["end_time"]:\n                            session_events.append(event)                    else:\n                        session_events.append(event)            return {                "session":\n session,                "events_captured":\n session_events[-20:\n],  # √öltimos 20 eventos                "total_events_in_session":\n len(session_events),            }# Instancia global del monitor espec√≠ficoreal_time_monitor = RealTimeSpecificMonitor()# ============================================# ENDPOINTS DE MONITOREO ESPEC√çFICO# ============================================@router.post("/start-specific-monitoring")async \ndef start_specific_monitoring_endpoint(    monitoring_request:\n Dict[str, Any],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üîç Iniciar monitoreo espec√≠fico de fallos 401    """    try:\n        session_id = monitoring_request.get(            "session_id", f"monitor_{int(time.time())}"        )        target_endpoints = monitoring_request.get("target_endpoints", [])        session = real_time_monitor.start_specific_monitoring(            session_id, target_endpoints        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "monitoring_session":\n session,        }    except Exception as e:\n        logger.error(f"Error iniciando monitoreo espec√≠fico:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/stop-monitoring/{session_id}")async \ndef stop_specific_monitoring_endpoint(    session_id:\n str,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ‚èπÔ∏è Detener monitoreo espec√≠fico    """    try:\n        session = real_time_monitor.stop_specific_monitoring(session_id)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "monitoring_session":\n session,        }    except Exception as e:\n        logger.error(f"Error deteniendo monitoreo espec√≠fico:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/capture-auth-event")async \ndef capture_auth_event_endpoint(    event_data:\n Dict[str, Any],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üì° Capturar evento de autenticaci√≥n en tiempo real    """    try:\n        event_type = event_data.get("event_type")        event_details = event_data.get("event_details", {})        if not event_type:\n            raise HTTPException(status_code=400, detail="event_type requerido")        real_time_monitor.capture_auth_event(event_type, event_details)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "captured",            "message":\n "Evento capturado",        }    except HTTPException:\n        raise    except Exception as e:\n        logger.error(f"Error capturando evento de autenticaci√≥n:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/failure-moments-analysis")async \ndef get_failure_moments_analysis(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üîç An√°lisis de momentos espec√≠ficos de fallo    """    try:\n        analysis = real_time_monitor.analyze_failure_moments()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n analysis,        }    except Exception as e:\n        logger.error(f"Error analizando momentos de fallo:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/real-time-status")async \ndef get_real_time_status_endpoint(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üìä Estado del monitoreo en tiempo real    """    try:\n        status = real_time_monitor.get_real_time_status()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "monitoring_status":\n status,        }    except Exception as e:\n        logger.error(f"Error obteniendo estado de monitoreo:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/monitoring-session/{session_id}")async \ndef get_monitoring_session_details_endpoint(    session_id:\n str,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üìã Detalles de sesi√≥n de monitoreo espec√≠fica    """    try:\n        details = real_time_monitor.get_monitoring_session_details(session_id)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "session_details":\n details,        }    except Exception as e:\n        logger.error(f"Error obteniendo detalles de sesi√≥n:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
