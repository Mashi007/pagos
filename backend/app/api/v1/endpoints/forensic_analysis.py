"""Sistema Forense de Análisis de Logs y TrazasReconstruye la secuencia exacta de eventos que llevan al error 401"""\nimport logging\nimport threading\nimport uuid\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA FORENSE DE TRAZAS# ============================================\nclass ForensicTraceSystem:\n    """Sistema forense para reconstruir eventos de autenticación"""    \ndef __init__(self):\n        self.trace_sessions = {}  # Sesiones de trazado activas        self.event_log = deque(maxlen=10000)  # Log de eventos        self.failed_sequences = deque(maxlen=1000)  # Secuencias que fallaron        self.lock = threading.Lock()    \ndef start_trace_session(        self, session_id:\n str, user_id:\n str = None    ) -> Dict[str, Any]:\n        """Iniciar sesión de trazado"""        with self.lock:\n            trace_session = {                "session_id":\n session_id,                "user_id":\n user_id,                "start_time":\n datetime.now(),                "events":\n [],                "status":\n "active",                "metadata":\n {},            }            self.trace_sessions[session_id] = trace_session            # Log evento de inicio            self._log_event(                "trace_session_started",                {                    "session_id":\n session_id,                    "user_id":\n user_id,                    "timestamp":\n trace_session["start_time"].isoformat(),                },            )            return trace_session    \ndef log_auth_event(        self, session_id:\n str, event_type:\n str, event_data:\n Dict[str, Any]    ):\n        """Registrar evento de autenticación"""        with self.lock:\n            if session_id not in self.trace_sessions:\n                return            event = {                "event_id":\n str(uuid.uuid4()),                "event_type":\n event_type,                "timestamp":\n datetime.now(),                "data":\n event_data,                "sequence_number":\n len(                    self.trace_sessions[session_id]["events"]                ),            }            self.trace_sessions[session_id]["events"].append(event)            # Log global            self._log_event(                event_type,                {                    "session_id":\n session_id,                    "event_id":\n event["event_id"],                    "data":\n event_data,                },            )            # Si es un evento de fallo, marcar secuencia como fallida            if event_type in [                "auth_failure",                "token_expired",                "validation_failed",            ]:\n                self._mark_sequence_as_failed(session_id, event)    \ndef _log_event(self, event_type:\n str, data:\n Dict[str, Any]):\n        """Log global de eventos"""        event_log = {            "event_type":\n event_type,            "timestamp":\n datetime.now(),            "data":\n data,        }        self.event_log.append(event_log)    \ndef _mark_sequence_as_failed(        self, session_id:\n str, failure_event:\n Dict[str, Any]    ):\n        """Marcar secuencia como fallida para análisis"""        if session_id in self.trace_sessions:\n            failed_sequence = {                "session_id":\n session_id,                "failure_event":\n failure_event,                "full_sequence":\n self.trace_sessions[session_id][                    "events"                ].copy(),                "failure_time":\n datetime.now(),                "user_id":\n self.trace_sessions[session_id].get("user_id"),            }            self.failed_sequences.append(failed_sequence)    \ndef end_trace_session(self, session_id:\n str, success:\n bool = True):\n        """Finalizar sesión de trazado"""        with self.lock:\n            if session_id in self.trace_sessions:\n                self.trace_sessions[session_id]["status"] = (                    "completed" if success else "failed"                )                self.trace_sessions[session_id]["end_time"] = datetime.now()                self._log_event(                    "trace_session_ended",                    {                        "session_id":\n session_id,                        "success":\n success,                        "duration_seconds":\n (                            (                                self.trace_sessions[session_id]["end_time"]                                - self.trace_sessions[session_id]["start_time"]                            ).total_seconds()                        ),                    },                )    \ndef analyze_failed_sequence(self, session_id:\n str) -> Dict[str, Any]:\n        """Analizar secuencia fallida específica"""        with self.lock:\n            # Buscar en secuencias fallidas            failed_seq = None            for seq in self.failed_sequences:\n                if seq["session_id"] == session_id:\n                    failed_seq = seq                    break            if not failed_seq:\n                return {"error":\n "Secuencia no encontrada o no falló"}            # Análisis forense            analysis = {                "session_id":\n session_id,                "failure_analysis":\n self._analyze_failure_pattern(failed_seq),                "timeline":\n self._build_timeline(failed_seq),                "root_cause_hypothesis":\n self._generate_root_cause_hypothesis(                    failed_seq                ),                "evidence":\n self._extract_evidence(failed_seq),            }            return analysis    \ndef _analyze_failure_pattern(        self, failed_seq:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Analizar patrón de fallo"""        events = failed_seq["full_sequence"]        failure_event = failed_seq["failure_event"]        # Análisis temporal        if len(events) >= 2:\n            time_to_failure = (                failure_event["timestamp"] - events[0]["timestamp"]            ).total_seconds()        else:\n            time_to_failure = 0        # Contar tipos de eventos        event_types = defaultdict(int)        for event in events:\n            event_types[event["event_type"]] += 1        # Identificar eventos sospechosos        suspicious_events = []        for event in events:\n            if event["event_type"] in [                "token_validation",                "user_lookup",                "permission_check",            ]:\n                if "error" in event.get("data", {}):\n                    suspicious_events.append(event)        return {            "time_to_failure_seconds":\n time_to_failure,            "total_events":\n len(events),            "event_type_counts":\n dict(event_types),            "suspicious_events_count":\n len(suspicious_events),            "failure_event_type":\n failure_event["event_type"],            "failure_data":\n failure_event["data"],        }    \ndef _build_timeline(        self, failed_seq:\n Dict[str, Any]    ) -> List[Dict[str, Any]]:\n        """Construir timeline de eventos"""        timeline = []        events = failed_seq["full_sequence"]        for i, event in enumerate(events):\n            timeline_entry = {                "sequence":\n i + 1,                "timestamp":\n event["timestamp"].isoformat(),                "event_type":\n event["event_type"],                "event_id":\n event["event_id"],                "summary":\n self._summarize_event(event),                "is_failure":\n event["event_id"]                == failed_seq["failure_event"]["event_id"],            }            timeline.append(timeline_entry)        return timeline    \ndef _summarize_event(self, event:\n Dict[str, Any]) -> str:\n        """Resumir evento para timeline"""        event_type = event["event_type"]        data = event.get("data", {})        summaries = {            "token_received":\n f"Token recibido:\n"            + f"{data.get('token_length' \            , 'unknown')} chars",            "token_validation":\n f"Validación token:\n {data.get('status' \            , 'unknown')}",            "user_lookup":\n f"Búsqueda usuario:\n {data.get('user_id', 'u \            nknown')}",            "permission_check":\n f"Verificación permisos:\n {data.get('pe \            rmission', 'unknown')}",            "auth_failure":\n f"Fallo autenticación:\n {data.get('reason', \            'unknown')}",            "token_expired":\n f"Token expirado:\n {data.get('exp_time',    'unknown')}",        }        return summaries.get(event_type, f"Evento {event_type}")    \ndef _generate_root_cause_hypothesis(        self, failed_seq:\n Dict[str, Any]    ) -> List[str]:\n        """Generar hipótesis de causa raíz"""        hypotheses = []        failure_event = failed_seq["failure_event"]        events = failed_seq["full_sequence"]        # Hipótesis basadas en el tipo de fallo        if failure_event["event_type"] == "token_expired":\n            hypotheses.append(                "Token JWT expirado - problema de sincronización de tiempo"            )            hypotheses.append(                "Token JWT expirado - configuración de expiración incorrecta"            )        elif failure_event["event_type"] == "auth_failure":\n            hypotheses.append(                "Credenciales inválidas - usuario no existe o inactivo"            )            hypotheses.append(                "Problema de base de datos - usuario no encontrado"            )            hypotheses.append(                "Token malformado - problema de codificación JWT"            )        elif failure_event["event_type"] == "validation_failed":\n            hypotheses.append("Validación JWT fallida - secret key incorrecta")            hypotheses.append("Validación JWT fallida - algoritmo incorrecto")            hypotheses.append("Token corrupto - problema de transmisión")        # Hipótesis basadas en patrones de eventos        event_types = [e["event_type"] for e in events]        if (            "token_received" in event_types            and "token_validation" not in event_types        ):\n            hypotheses.append(                "Token recibido pero no validado - problema en middleware"            )        if len(events) == 1:\n            hypotheses.append(                "Fallo inmediato - problema en configuración inicial"            )        return hypotheses    \ndef _extract_evidence(self, failed_seq:\n Dict[str, Any]) -> Dict[str, Any]:\n        """Extraer evidencia específica"""        evidence = {            "token_evidence":\n {},            "user_evidence":\n {},            "timing_evidence":\n {},            "system_evidence":\n {},        }        events = failed_seq["full_sequence"]        failure_event = failed_seq["failure_event"]        # Evidencia de token        for event in events:\n            if event["event_type"] == "token_received":\n                evidence["token_evidence"] = event["data"]            elif event["event_type"] == "token_validation":\n                evidence["token_evidence"].update(event["data"])        # Evidencia de usuario        for event in events:\n            if event["event_type"] == "user_lookup":\n                evidence["user_evidence"] = event["data"]        # Evidencia de timing        if len(events) >= 2:\n            evidence["timing_evidence"] = {                "first_event_time":\n events[0]["timestamp"].isoformat(),                "failure_time":\n failure_event["timestamp"].isoformat(),                "total_duration_ms":\n (                    (                        failure_event["timestamp"] - events[0]["timestamp"]                    ).total_seconds()                    * 1000                ),            }        # Evidencia del sistema        evidence["system_evidence"] = {            "failure_event_data":\n failure_event["data"],            "total_events_before_failure":\n len(events) - 1,            "session_user_id":\n failed_seq.get("user_id"),        }        return evidence    \ndef get_forensic_summary(self) -> Dict[str, Any]:\n        """Obtener resumen forense general"""        with self.lock:\n            current_time = datetime.now()            cutoff_time = current_time - timedelta(                hours=24            )  # Últimas 24 horas            # Filtrar eventos recientes            recent_events = [                event                for event in self.event_log                if event["timestamp"] > cutoff_time            ]            # Contar tipos de eventos            event_type_counts = defaultdict(int)            for event in recent_events:\n                event_type_counts[event["event_type"]] += 1            # Análisis de secuencias fallidas            recent_failures = [                seq                for seq in self.failed_sequences                if seq["failure_time"] > cutoff_time            ]            # Patrones de fallo más comunes            failure_patterns = defaultdict(int)            for failure in recent_failures:\n                failure_patterns[failure["failure_event"]["event_type"]] += 1            return {                "timestamp":\n current_time.isoformat(),                "summary":\n {                    "total_events_24h":\n len(recent_events),                    "total_failures_24h":\n len(recent_failures),                    "active_trace_sessions":\n len(                        [                            s                            for s in self.trace_sessions.values()                            if s["status"] == "active"                        ]                    ),                    "event_type_distribution":\n dict(event_type_counts),                    "failure_pattern_distribution":\n dict(failure_patterns),                },                "recent_failures":\n (                    recent_failures[-10:\n] if recent_failures else []                ),                "recommendations":\n self._generate_forensic_recommendations(                    recent_failures                ),            }    \ndef _generate_forensic_recommendations(        self, recent_failures:\n List[Dict[str, Any]]    ) -> List[str]:\n        """Generar recomendaciones basadas en evidencia forense"""        recommendations = []        if not recent_failures:\n            recommendations.append(                "✅ No hay fallos recientes - sistema estable"            )            return recommendations        # Analizar patrones de fallo        failure_types = [            f["failure_event"]["event_type"] for f in recent_failures        ]        if failure_types.count("token_expired") > len(failure_types) * 0.5:\n            recommendations.append(                "🔴 Más del 50% de fallos son por tokens expirados -     revisar configuración de expiración"            )        if failure_types.count("auth_failure") > len(failure_types) * 0.3:\n            recommendations.append(                "🟡 Más del 30% de fallos son de autenticación -     revisar validación de usuarios"            )        if failure_types.count("validation_failed") > len(failure_types) * 0.2:\n            recommendations.append(                "🟡 Más del 20% de fallos son de validación -     revisar configuración JWT"            )        # Recomendaciones de timing        avg_time_to_failure = sum(            (                f["failure_time"] - f["full_sequence"][0]["timestamp"]            ).total_seconds()            for f in recent_failures            if f["full_sequence"]        ) / len(recent_failures)        if avg_time_to_failure < 1:\n            recommendations.append(                "⚡ Fallos muy rápidos -     posible problema de configuración inicial"            )        return recommendations# Instancia global del sistema forenseforensic_system = ForensicTraceSystem()# ============================================# ENDPOINTS FORENSES# ============================================@router.post("/start-trace")async \ndef start_forensic_trace(    trace_data:\n Dict[str, str],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    🔍 Iniciar sesión de trazado forense    """    try:\n        session_id = trace_data.get("session_id", str(uuid.uuid4()))        user_id = trace_data.get("user_id")        trace_session = forensic_system.start_trace_session(            session_id, user_id        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "trace_session":\n trace_session,        }    except Exception as e:\n        logger.error(f"Error iniciando trazado forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/log-auth-event")async \ndef log_auth_event_endpoint(    event_data:\n Dict[str, Any],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    📝 Registrar evento de autenticación para análisis forense    """    try:\n        session_id = event_data.get("session_id")        event_type = event_data.get("event_type")        event_data_dict = event_data.get("data", {})        if not session_id or not event_type:\n            raise HTTPException(                status_code=400, detail="session_id y event_type requeridos"            )        forensic_system.log_auth_event(session_id, event_type, event_data_dict)        return {"timestamp":\n datetime.now().isoformat(), "status":\n "logged"}    except HTTPException:\n        raise    except Exception as e:\n        logger.error(f"Error registrando evento de autenticación:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/analyze-failure/{session_id}")async \ndef analyze_failure_sequence(    session_id:\n str,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    🔍 Analizar secuencia fallida específica    """    try:\n        analysis = forensic_system.analyze_failed_sequence(session_id)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n analysis,        }    except Exception as e:\n        logger.error(f"Error analizando secuencia fallida:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/forensic-summary")async \ndef get_forensic_summary_endpoint(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    📊 Resumen forense general    """    try:\n        summary = forensic_system.get_forensic_summary()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "summary":\n summary,        }    except Exception as e:\n        logger.error(f"Error obteniendo resumen forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/end-trace/{session_id}")async \ndef end_forensic_trace(    session_id:\n str,    success_data:\n Dict[str, bool],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ✅ Finalizar sesión de trazado forense    """    try:\n        success = success_data.get("success", True)        forensic_system.end_trace_session(session_id, success)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "message":\n f"Sesión {session_id} finalizada",        }    except Exception as e:\n        logger.error(f"Error finalizando trazado forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
