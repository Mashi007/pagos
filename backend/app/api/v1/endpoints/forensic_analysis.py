"""Sistema Forense de AnÃ¡lisis de Logs y TrazasReconstruye la secuencia exacta de eventos que llevan al error 401"""\nimport logging\nimport threading\nimport uuid\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA FORENSE DE TRAZAS# ============================================\nclass ForensicTraceSystem:\n    """Sistema forense para reconstruir eventos de autenticaciÃ³n"""    \ndef __init__(self):\n        self.trace_sessions = {}  # Sesiones de trazado activas        self.event_log = deque(maxlen=10000)  # Log de eventos        self.failed_sequences = deque(maxlen=1000)  # Secuencias que fallaron        self.lock = threading.Lock()    \ndef start_trace_session(        self, session_id:\n str, user_id:\n str = None    ) -> Dict[str, Any]:\n        """Iniciar sesiÃ³n de trazado"""        with self.lock:\n            trace_session = {                "session_id":\n session_id,                "user_id":\n user_id,                "start_time":\n datetime.now(),                "events":\n [],                "status":\n "active",                "metadata":\n {},            }            self.trace_sessions[session_id] = trace_session            # Log evento de inicio            self._log_event(                "trace_session_started",                {                    "session_id":\n session_id,                    "user_id":\n user_id,                    "timestamp":\n trace_session["start_time"].isoformat(),                },            )            return trace_session    \ndef log_auth_event(        self, session_id:\n str, event_type:\n str, event_data:\n Dict[str, Any]    ):\n        """Registrar evento de autenticaciÃ³n"""        with self.lock:\n            if session_id not in self.trace_sessions:\n                return            event = {                "event_id":\n str(uuid.uuid4()),                "event_type":\n event_type,                "timestamp":\n datetime.now(),                "data":\n event_data,                "sequence_number":\n len(                    self.trace_sessions[session_id]["events"]                ),            }            self.trace_sessions[session_id]["events"].append(event)            # Log global            self._log_event(                event_type,                {                    "session_id":\n session_id,                    "event_id":\n event["event_id"],                    "data":\n event_data,                },            )            # Si es un evento de fallo, marcar secuencia como fallida            if event_type in [                "auth_failure",                "token_expired",                "validation_failed",            ]:\n                self._mark_sequence_as_failed(session_id, event)    \ndef _log_event(self, event_type:\n str, data:\n Dict[str, Any]):\n        """Log global de eventos"""        event_log = {            "event_type":\n event_type,            "timestamp":\n datetime.now(),            "data":\n data,        }        self.event_log.append(event_log)    \ndef _mark_sequence_as_failed(        self, session_id:\n str, failure_event:\n Dict[str, Any]    ):\n        """Marcar secuencia como fallida para anÃ¡lisis"""        if session_id in self.trace_sessions:\n            failed_sequence = {                "session_id":\n session_id,                "failure_event":\n failure_event,                "full_sequence":\n self.trace_sessions[session_id][                    "events"                ].copy(),                "failure_time":\n datetime.now(),                "user_id":\n self.trace_sessions[session_id].get("user_id"),            }            self.failed_sequences.append(failed_sequence)    \ndef end_trace_session(self, session_id:\n str, success:\n bool = True):\n        """Finalizar sesiÃ³n de trazado"""        with self.lock:\n            if session_id in self.trace_sessions:\n                self.trace_sessions[session_id]["status"] = (                    "completed" if success else "failed"                )                self.trace_sessions[session_id]["end_time"] = datetime.now()                self._log_event(                    "trace_session_ended",                    {                        "session_id":\n session_id,                        "success":\n success,                        "duration_seconds":\n (                            (                                self.trace_sessions[session_id]["end_time"]                                - self.trace_sessions[session_id]["start_time"]                            ).total_seconds()                        ),                    },                )    \ndef analyze_failed_sequence(self, session_id:\n str) -> Dict[str, Any]:\n        """Analizar secuencia fallida especÃ­fica"""        with self.lock:\n            # Buscar en secuencias fallidas            failed_seq = None            for seq in self.failed_sequences:\n                if seq["session_id"] == session_id:\n                    failed_seq = seq                    break            if not failed_seq:\n                return {"error":\n "Secuencia no encontrada o no fallÃ³"}            # AnÃ¡lisis forense            analysis = {                "session_id":\n session_id,                "failure_analysis":\n self._analyze_failure_pattern(failed_seq),                "timeline":\n self._build_timeline(failed_seq),                "root_cause_hypothesis":\n self._generate_root_cause_hypothesis(                    failed_seq                ),                "evidence":\n self._extract_evidence(failed_seq),            }            return analysis    \ndef _analyze_failure_pattern(        self, failed_seq:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Analizar patrÃ³n de fallo"""        events = failed_seq["full_sequence"]        failure_event = failed_seq["failure_event"]        # AnÃ¡lisis temporal        if len(events) >= 2:\n            time_to_failure = (                failure_event["timestamp"] - events[0]["timestamp"]            ).total_seconds()        else:\n            time_to_failure = 0        # Contar tipos de eventos        event_types = defaultdict(int)        for event in events:\n            event_types[event["event_type"]] += 1        # Identificar eventos sospechosos        suspicious_events = []        for event in events:\n            if event["event_type"] in [                "token_validation",                "user_lookup",                "permission_check",            ]:\n                if "error" in event.get("data", {}):\n                    suspicious_events.append(event)        return {            "time_to_failure_seconds":\n time_to_failure,            "total_events":\n len(events),            "event_type_counts":\n dict(event_types),            "suspicious_events_count":\n len(suspicious_events),            "failure_event_type":\n failure_event["event_type"],            "failure_data":\n failure_event["data"],        }    \ndef _build_timeline(        self, failed_seq:\n Dict[str, Any]    ) -> List[Dict[str, Any]]:\n        """Construir timeline de eventos"""        timeline = []        events = failed_seq["full_sequence"]        for i, event in enumerate(events):\n            timeline_entry = {                "sequence":\n i + 1,                "timestamp":\n event["timestamp"].isoformat(),                "event_type":\n event["event_type"],                "event_id":\n event["event_id"],                "summary":\n self._summarize_event(event),                "is_failure":\n event["event_id"]                == failed_seq["failure_event"]["event_id"],            }            timeline.append(timeline_entry)        return timeline    \ndef _summarize_event(self, event:\n Dict[str, Any]) -> str:\n        """Resumir evento para timeline"""        event_type = event["event_type"]        data = event.get("data", {})        summaries = {            "token_received":\n f"Token recibido:\n"            + f"{data.get('token_length' \            , 'unknown')} chars",            "token_validation":\n f"ValidaciÃ³n token:\n {data.get('status' \            , 'unknown')}",            "user_lookup":\n f"BÃºsqueda usuario:\n {data.get('user_id', 'u \            nknown')}",            "permission_check":\n f"VerificaciÃ³n permisos:\n {data.get('pe \            rmission', 'unknown')}",            "auth_failure":\n f"Fallo autenticaciÃ³n:\n {data.get('reason', \            'unknown')}",            "token_expired":\n f"Token expirado:\n {data.get('exp_time',    'unknown')}",        }        return summaries.get(event_type, f"Evento {event_type}")    \ndef _generate_root_cause_hypothesis(        self, failed_seq:\n Dict[str, Any]    ) -> List[str]:\n        """Generar hipÃ³tesis de causa raÃ­z"""        hypotheses = []        failure_event = failed_seq["failure_event"]        events = failed_seq["full_sequence"]        # HipÃ³tesis basadas en el tipo de fallo        if failure_event["event_type"] == "token_expired":\n            hypotheses.append(                "Token JWT expirado - problema de sincronizaciÃ³n de tiempo"            )            hypotheses.append(                "Token JWT expirado - configuraciÃ³n de expiraciÃ³n incorrecta"            )        elif failure_event["event_type"] == "auth_failure":\n            hypotheses.append(                "Credenciales invÃ¡lidas - usuario no existe o inactivo"            )            hypotheses.append(                "Problema de base de datos - usuario no encontrado"            )            hypotheses.append(                "Token malformado - problema de codificaciÃ³n JWT"            )        elif failure_event["event_type"] == "validation_failed":\n            hypotheses.append("ValidaciÃ³n JWT fallida - secret key incorrecta")            hypotheses.append("ValidaciÃ³n JWT fallida - algoritmo incorrecto")            hypotheses.append("Token corrupto - problema de transmisiÃ³n")        # HipÃ³tesis basadas en patrones de eventos        event_types = [e["event_type"] for e in events]        if (            "token_received" in event_types            and "token_validation" not in event_types        ):\n            hypotheses.append(                "Token recibido pero no validado - problema en middleware"            )        if len(events) == 1:\n            hypotheses.append(                "Fallo inmediato - problema en configuraciÃ³n inicial"            )        return hypotheses    \ndef _extract_evidence(self, failed_seq:\n Dict[str, Any]) -> Dict[str, Any]:\n        """Extraer evidencia especÃ­fica"""        evidence = {            "token_evidence":\n {},            "user_evidence":\n {},            "timing_evidence":\n {},            "system_evidence":\n {},        }        events = failed_seq["full_sequence"]        failure_event = failed_seq["failure_event"]        # Evidencia de token        for event in events:\n            if event["event_type"] == "token_received":\n                evidence["token_evidence"] = event["data"]            elif event["event_type"] == "token_validation":\n                evidence["token_evidence"].update(event["data"])        # Evidencia de usuario        for event in events:\n            if event["event_type"] == "user_lookup":\n                evidence["user_evidence"] = event["data"]        # Evidencia de timing        if len(events) >= 2:\n            evidence["timing_evidence"] = {                "first_event_time":\n events[0]["timestamp"].isoformat(),                "failure_time":\n failure_event["timestamp"].isoformat(),                "total_duration_ms":\n (                    (                        failure_event["timestamp"] - events[0]["timestamp"]                    ).total_seconds()                    * 1000                ),            }        # Evidencia del sistema        evidence["system_evidence"] = {            "failure_event_data":\n failure_event["data"],            "total_events_before_failure":\n len(events) - 1,            "session_user_id":\n failed_seq.get("user_id"),        }        return evidence    \ndef get_forensic_summary(self) -> Dict[str, Any]:\n        """Obtener resumen forense general"""        with self.lock:\n            current_time = datetime.now()            cutoff_time = current_time - timedelta(                hours=24            )  # Ãšltimas 24 horas            # Filtrar eventos recientes            recent_events = [                event                for event in self.event_log                if event["timestamp"] > cutoff_time            ]            # Contar tipos de eventos            event_type_counts = defaultdict(int)            for event in recent_events:\n                event_type_counts[event["event_type"]] += 1            # AnÃ¡lisis de secuencias fallidas            recent_failures = [                seq                for seq in self.failed_sequences                if seq["failure_time"] > cutoff_time            ]            # Patrones de fallo mÃ¡s comunes            failure_patterns = defaultdict(int)            for failure in recent_failures:\n                failure_patterns[failure["failure_event"]["event_type"]] += 1            return {                "timestamp":\n current_time.isoformat(),                "summary":\n {                    "total_events_24h":\n len(recent_events),                    "total_failures_24h":\n len(recent_failures),                    "active_trace_sessions":\n len(                        [                            s                            for s in self.trace_sessions.values()                            if s["status"] == "active"                        ]                    ),                    "event_type_distribution":\n dict(event_type_counts),                    "failure_pattern_distribution":\n dict(failure_patterns),                },                "recent_failures":\n (                    recent_failures[-10:\n] if recent_failures else []                ),                "recommendations":\n self._generate_forensic_recommendations(                    recent_failures                ),            }    \ndef _generate_forensic_recommendations(        self, recent_failures:\n List[Dict[str, Any]]    ) -> List[str]:\n        """Generar recomendaciones basadas en evidencia forense"""        recommendations = []        if not recent_failures:\n            recommendations.append(                "âœ… No hay fallos recientes - sistema estable"            )            return recommendations        # Analizar patrones de fallo        failure_types = [            f["failure_event"]["event_type"] for f in recent_failures        ]        if failure_types.count("token_expired") > len(failure_types) * 0.5:\n            recommendations.append(                "ðŸ”´ MÃ¡s del 50% de fallos son por tokens expirados -     revisar configuraciÃ³n de expiraciÃ³n"            )        if failure_types.count("auth_failure") > len(failure_types) * 0.3:\n            recommendations.append(                "ðŸŸ¡ MÃ¡s del 30% de fallos son de autenticaciÃ³n -     revisar validaciÃ³n de usuarios"            )        if failure_types.count("validation_failed") > len(failure_types) * 0.2:\n            recommendations.append(                "ðŸŸ¡ MÃ¡s del 20% de fallos son de validaciÃ³n -     revisar configuraciÃ³n JWT"            )        # Recomendaciones de timing        avg_time_to_failure = sum(            (                f["failure_time"] - f["full_sequence"][0]["timestamp"]            ).total_seconds()            for f in recent_failures            if f["full_sequence"]        ) / len(recent_failures)        if avg_time_to_failure < 1:\n            recommendations.append(                "âš¡ Fallos muy rÃ¡pidos -     posible problema de configuraciÃ³n inicial"            )        return recommendations# Instancia global del sistema forenseforensic_system = ForensicTraceSystem()# ============================================# ENDPOINTS FORENSES# ============================================@router.post("/start-trace")async \ndef start_forensic_trace(    trace_data:\n Dict[str, str],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ” Iniciar sesiÃ³n de trazado forense    """    try:\n        session_id = trace_data.get("session_id", str(uuid.uuid4()))        user_id = trace_data.get("user_id")        trace_session = forensic_system.start_trace_session(            session_id, user_id        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "trace_session":\n trace_session,        }    except Exception as e:\n        logger.error(f"Error iniciando trazado forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/log-auth-event")async \ndef log_auth_event_endpoint(    event_data:\n Dict[str, Any],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ“ Registrar evento de autenticaciÃ³n para anÃ¡lisis forense    """    try:\n        session_id = event_data.get("session_id")        event_type = event_data.get("event_type")        event_data_dict = event_data.get("data", {})        if not session_id or not event_type:\n            raise HTTPException(                status_code=400, detail="session_id y event_type requeridos"            )        forensic_system.log_auth_event(session_id, event_type, event_data_dict)        return {"timestamp":\n datetime.now().isoformat(), "status":\n "logged"}    except HTTPException:\n        raise    except Exception as e:\n        logger.error(f"Error registrando evento de autenticaciÃ³n:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/analyze-failure/{session_id}")async \ndef analyze_failure_sequence(    session_id:\n str,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ” Analizar secuencia fallida especÃ­fica    """    try:\n        analysis = forensic_system.analyze_failed_sequence(session_id)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n analysis,        }    except Exception as e:\n        logger.error(f"Error analizando secuencia fallida:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/forensic-summary")async \ndef get_forensic_summary_endpoint(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ“Š Resumen forense general    """    try:\n        summary = forensic_system.get_forensic_summary()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "summary":\n summary,        }    except Exception as e:\n        logger.error(f"Error obteniendo resumen forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/end-trace/{session_id}")async \ndef end_forensic_trace(    session_id:\n str,    success_data:\n Dict[str, bool],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    âœ… Finalizar sesiÃ³n de trazado forense    """    try:\n        success = success_data.get("success", True)        forensic_system.end_trace_session(session_id, success)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "message":\n f"SesiÃ³n {session_id} finalizada",        }    except Exception as e:\n        logger.error(f"Error finalizando trazado forense:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
