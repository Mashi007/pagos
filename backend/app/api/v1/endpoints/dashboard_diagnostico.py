"""Dashboard de Diagnóstico en Tiempo RealSistema de monitoreo y auditoría para problemas de autenticación"""\nimport logging\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends, Request, Response\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_db\nfrom app.core.config \nimport settings\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# Almacenamiento en memoria para auditoríaaudit_logs = deque(maxlen=1000)  # Mantener últimos 1000 logserror_patterns = defaultdict(int)request_stats = defaultdict(int)\nclass AuditLogger:\n    """Logger especializado para auditoría de autenticación"""    @staticmethod    \ndef log_request(        request:\n Request,        response:\n Response,        user_id:\n str = None,        error:\n str = None,    ):\n        """Registrar request en auditoría"""        timestamp = datetime.now()        log_entry = {            "timestamp":\n timestamp.isoformat(),            "method":\n request.method,            "url":\n str(request.url),            "status_code":\n response.status_code,            "user_id":\n user_id,            "user_agent":\n request.headers.get("user-agent", "unknown"),            "ip":\n request.client.host if request.client else "unknown",            "error":\n error,            "auth_header_present":\n "authorization" in request.headers,            "auth_header_type":\n (                request.headers.get("authorization", "").split(" ")[0]                if request.headers.get("authorization")                else None            ),        }        # Agregar al log        audit_logs.append(log_entry)        # Actualizar estadísticas        request_stats[f"status_{response.status_code}"] += 1        if error:\n            error_patterns[error] += 1        # Log específico para errores 401        if response.status_code == 401:\n            logger.warning(                f"🔒 401 Unauthorized -"                + f"{request.method} {request.url} \                - Error:\n {error}"            )    @staticmethod    \ndef get_recent_logs(minutes:\n int = 60) -> List[Dict]:\n        """Obtener logs recientes"""        cutoff = datetime.now() - timedelta(minutes=minutes)        return [            log            for log in audit_logs            if datetime.fromisoformat(log["timestamp"]) > cutoff        ]    @staticmethod    \ndef get_error_summary() -> Dict[str, Any]:\n        """Resumen de errores"""        recent_logs = AuditLogger.get_recent_logs(60)        # Agrupar por tipo de error        error_counts = defaultdict(int)        status_counts = defaultdict(int)        for log in recent_logs:\n            if log["error"]:\n                error_counts[log["error"]] += 1            status_counts[log["status_code"]] += 1        return {            "total_requests":\n len(recent_logs),            "error_counts":\n dict(error_counts),            "status_counts":\n dict(status_counts),            "time_range":\n "last_60_minutes",        }@router.get("/dashboard")async \ndef dashboard_diagnostico(db:\n Session = Depends(get_db)):\n    """    📊 Dashboard principal de diagnóstico    """    try:\n        # 1. Estadísticas generales del sistema        system_stats = {            "timestamp":\n datetime.now().isoformat(),            "environment":\n settings.ENVIRONMENT,            "debug_mode":\n settings.DEBUG,            "cors_origins_count":\n len(settings.CORS_ORIGINS),        }        # 2. Estadísticas de usuarios        try:\n            total_users = db.query(User).count()            active_users = db.query(User).filter(User.is_active).count()            admin_users = db.query(User).filter(User.is_admin).count()            user_stats = {                "total_users":\n total_users,                "active_users":\n active_users,                "admin_users":\n admin_users,                "inactive_users":\n total_users - active_users,            }        except Exception as e:\n            user_stats = {"error":\n str(e)}        # 3. Estadísticas de requests        request_stats_summary = AuditLogger.get_error_summary()        # 4. Logs recientes (últimos 20)        recent_logs = AuditLogger.get_recent_logs(60)[-20:\n]        # 5. Patrones de error más comunes        top_errors = sorted(            error_patterns.items(), key=lambda x:\n x[1], reverse=True        )[:\n5]        # 6. Análisis de autenticación        auth_analysis = {            "total_401_errors":\n request_stats_summary["status_counts"].get(                401, 0            ),            "total_requests":\n request_stats_summary["total_requests"],            "error_rate":\n (                (                    request_stats_summary["status_counts"].get(401, 0)                    / max(request_stats_summary["total_requests"], 1)                )                * 100            ),        }        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "dashboard":\n {                "system":\n system_stats,                "users":\n user_stats,                "requests":\n request_stats_summary,                "auth_analysis":\n auth_analysis,                "top_errors":\n top_errors,                "recent_logs":\n recent_logs,            },            "recommendations":\n _generate_dashboard_recommendations(                auth_analysis, user_stats            ),        }    except Exception as e:\n        logger.error(f"Error en dashboard de diagnóstico:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/logs")async \ndef obtener_logs_auditoria(minutes:\n int = 60, limit:\n int = 100):\n    """    📝 Obtener logs de auditoría    """    try:\n        logs = AuditLogger.get_recent_logs(minutes)        # Limitar resultados        if limit:\n            logs = logs[-limit:\n]        # Filtrar solo errores si se solicita        error_logs = [log for log in logs if log["status_code"] >= 400]        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "logs":\n {                "total_logs":\n len(logs),                "error_logs":\n len(error_logs),                "time_range_minutes":\n minutes,                "logs":\n logs,                "error_summary":\n AuditLogger.get_error_summary(),            },        }    except Exception as e:\n        logger.error(f"Error obteniendo logs de auditoría:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/health-check")async \ndef health_check_detallado(db:\n Session = Depends(get_db)):\n    """    🏥 Health check detallado del sistema    """    try:\n        checks = {}        # 1. Verificar conexión a BD        try:\n            db.execute("SELECT 1")            checks["database"] = {                "status":\n "healthy",                "message":\n "Database connection OK",            }        except Exception as e:\n            checks["database"] = {                "status":\n "unhealthy",                "message":\n f"Database error:\n {str(e)}",            }        # 2. Verificar configuración JWT        jwt_ok = bool(settings.SECRET_KEY and len(settings.SECRET_KEY) >= 32)        checks["jwt_config"] = {            "status":\n "healthy" if jwt_ok else "unhealthy",            "message":\n (                "JWT configuration OK"                if jwt_ok                else "JWT configuration issues"            ),            "secret_key_length":\n (                len(settings.SECRET_KEY) if settings.SECRET_KEY else 0            ),        }        # 3. Verificar usuarios admin        try:\n            admin_count = db.query(User).filter(User.is_admin).count()            admin_ok = admin_count > 0            checks["admin_users"] = {                "status":\n "healthy" if admin_ok else "unhealthy",                "message":\n (                    f"Found {admin_count} admin users"                    if admin_ok                    else "No admin users found"                ),                "count":\n admin_count,            }        except Exception as e:\n            checks["admin_users"] = {                "status":\n "unhealthy",                "message":\n f"Error checking admin users:\n {str(e)}",            }        # 4. Verificar logs de auditoría        recent_logs = AuditLogger.get_recent_logs(5)  # Últimos 5 minutos        error_rate = len(            [log for log in recent_logs if log["status_code"] >= 400]        ) / max(len(recent_logs), 1)        checks["audit_logs"] = {            "status":\n "healthy" if error_rate < 0.5 else "warning",            "message":\n f"Error rate:\n {error_rate:\n.2%}",            "recent_requests":\n len(recent_logs),            "error_rate":\n error_rate,        }        # Estado general        overall_status = "healthy"        if any(check["status"] == "unhealthy" for check in checks.values()):\n            overall_status = "unhealthy"        elif any(check["status"] == "warning" for check in checks.values()):\n            overall_status = "warning"        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n overall_status,            "checks":\n checks,            "summary":\n {                "total_checks":\n len(checks),                "healthy_checks":\n len(                    [c for c in checks.values() if c["status"] == "healthy"]                ),                "warning_checks":\n len(                    [c for c in checks.values() if c["status"] == "warning"]                ),                "unhealthy_checks":\n len(                    [c for c in checks.values() if c["status"] == "unhealthy"]                ),            },        }    except Exception as e:\n        logger.error(f"Error en health check detallado:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/clear-logs")async \ndef limpiar_logs_auditoria():\n    """    🧹 Limpiar logs de auditoría    """    try:\n        # Limpiar logs        audit_logs.clear()        error_patterns.clear()        request_stats.clear()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "message":\n "Audit logs cleared successfully",        }    except Exception as e:\n        logger.error(f"Error limpiando logs:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }\ndef _generate_dashboard_recommendations(    auth_analysis:\n Dict, user_stats:\n Dict) -> List[str]:\n    """Generar recomendaciones basadas en el análisis del dashboard"""    recommendations = []    # Análisis de tasa de error    error_rate = auth_analysis.get("error_rate", 0)    if error_rate > 50:\n        recommendations.append(            "🚨 Tasa de error muy alta (>50%) - Revisar configuración de \            autenticación"        )    elif error_rate > 20:\n        recommendations.append(            "⚠️ Tasa de error elevada (>20%) -     Monitorear logs de autenticación"        )    # Análisis de usuarios    if user_stats.get("admin_users", 0) == 0:\n        recommendations.append(            "👤 No hay usuarios administradores - Crear usuario admin"        )    if user_stats.get("active_users", 0) == 0:\n        recommendations.append(            "⚠️ No hay usuarios activos - Verificar estado de usuarios"        )    # Recomendaciones generales    if not recommendations:\n        recommendations.append("✅ Sistema funcionando correctamente")    return recommendations# Nota:\n Middleware removido - APIRouter no soporta middleware directamente# El middleware debe ser agregado a la aplicación principal en main.py
