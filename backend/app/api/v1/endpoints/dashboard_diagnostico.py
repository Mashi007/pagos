"""Dashboard de Diagn√≥stico en Tiempo RealSistema de monitoreo y auditor√≠a para problemas de autenticaci√≥n"""\nimport logging\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends, Request, Response\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_db\nfrom app.core.config \nimport settings\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# Almacenamiento en memoria para auditor√≠aaudit_logs = deque(maxlen=1000)  # Mantener √∫ltimos 1000 logserror_patterns = defaultdict(int)request_stats = defaultdict(int)\nclass AuditLogger:\n    """Logger especializado para auditor√≠a de autenticaci√≥n"""    @staticmethod    \ndef log_request(        request:\n Request,        response:\n Response,        user_id:\n str = None,        error:\n str = None,    ):\n        """Registrar request en auditor√≠a"""        timestamp = datetime.now()        log_entry = {            "timestamp":\n timestamp.isoformat(),            "method":\n request.method,            "url":\n str(request.url),            "status_code":\n response.status_code,            "user_id":\n user_id,            "user_agent":\n request.headers.get("user-agent", "unknown"),            "ip":\n request.client.host if request.client else "unknown",            "error":\n error,            "auth_header_present":\n "authorization" in request.headers,            "auth_header_type":\n (                request.headers.get("authorization", "").split(" ")[0]                if request.headers.get("authorization")                else None            ),        }        # Agregar al log        audit_logs.append(log_entry)        # Actualizar estad√≠sticas        request_stats[f"status_{response.status_code}"] += 1        if error:\n            error_patterns[error] += 1        # Log espec√≠fico para errores 401        if response.status_code == 401:\n            logger.warning(                f"üîí 401 Unauthorized -"                + f"{request.method} {request.url} \                - Error:\n {error}"            )    @staticmethod    \ndef get_recent_logs(minutes:\n int = 60) -> List[Dict]:\n        """Obtener logs recientes"""        cutoff = datetime.now() - timedelta(minutes=minutes)        return [            log            for log in audit_logs            if datetime.fromisoformat(log["timestamp"]) > cutoff        ]    @staticmethod    \ndef get_error_summary() -> Dict[str, Any]:\n        """Resumen de errores"""        recent_logs = AuditLogger.get_recent_logs(60)        # Agrupar por tipo de error        error_counts = defaultdict(int)        status_counts = defaultdict(int)        for log in recent_logs:\n            if log["error"]:\n                error_counts[log["error"]] += 1            status_counts[log["status_code"]] += 1        return {            "total_requests":\n len(recent_logs),            "error_counts":\n dict(error_counts),            "status_counts":\n dict(status_counts),            "time_range":\n "last_60_minutes",        }@router.get("/dashboard")async \ndef dashboard_diagnostico(db:\n Session = Depends(get_db)):\n    """    üìä Dashboard principal de diagn√≥stico    """    try:\n        # 1. Estad√≠sticas generales del sistema        system_stats = {            "timestamp":\n datetime.now().isoformat(),            "environment":\n settings.ENVIRONMENT,            "debug_mode":\n settings.DEBUG,            "cors_origins_count":\n len(settings.CORS_ORIGINS),        }        # 2. Estad√≠sticas de usuarios        try:\n            total_users = db.query(User).count()            active_users = db.query(User).filter(User.is_active).count()            admin_users = db.query(User).filter(User.is_admin).count()            user_stats = {                "total_users":\n total_users,                "active_users":\n active_users,                "admin_users":\n admin_users,                "inactive_users":\n total_users - active_users,            }        except Exception as e:\n            user_stats = {"error":\n str(e)}        # 3. Estad√≠sticas de requests        request_stats_summary = AuditLogger.get_error_summary()        # 4. Logs recientes (√∫ltimos 20)        recent_logs = AuditLogger.get_recent_logs(60)[-20:\n]        # 5. Patrones de error m√°s comunes        top_errors = sorted(            error_patterns.items(), key=lambda x:\n x[1], reverse=True        )[:\n5]        # 6. An√°lisis de autenticaci√≥n        auth_analysis = {            "total_401_errors":\n request_stats_summary["status_counts"].get(                401, 0            ),            "total_requests":\n request_stats_summary["total_requests"],            "error_rate":\n (                (                    request_stats_summary["status_counts"].get(401, 0)                    / max(request_stats_summary["total_requests"], 1)                )                * 100            ),        }        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "dashboard":\n {                "system":\n system_stats,                "users":\n user_stats,                "requests":\n request_stats_summary,                "auth_analysis":\n auth_analysis,                "top_errors":\n top_errors,                "recent_logs":\n recent_logs,            },            "recommendations":\n _generate_dashboard_recommendations(                auth_analysis, user_stats            ),        }    except Exception as e:\n        logger.error(f"Error en dashboard de diagn√≥stico:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/logs")async \ndef obtener_logs_auditoria(minutes:\n int = 60, limit:\n int = 100):\n    """    üìù Obtener logs de auditor√≠a    """    try:\n        logs = AuditLogger.get_recent_logs(minutes)        # Limitar resultados        if limit:\n            logs = logs[-limit:\n]        # Filtrar solo errores si se solicita        error_logs = [log for log in logs if log["status_code"] >= 400]        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "logs":\n {                "total_logs":\n len(logs),                "error_logs":\n len(error_logs),                "time_range_minutes":\n minutes,                "logs":\n logs,                "error_summary":\n AuditLogger.get_error_summary(),            },        }    except Exception as e:\n        logger.error(f"Error obteniendo logs de auditor√≠a:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/health-check")async \ndef health_check_detallado(db:\n Session = Depends(get_db)):\n    """    üè• Health check detallado del sistema    """    try:\n        checks = {}        # 1. Verificar conexi√≥n a BD        try:\n            db.execute("SELECT 1")            checks["database"] = {                "status":\n "healthy",                "message":\n "Database connection OK",            }        except Exception as e:\n            checks["database"] = {                "status":\n "unhealthy",                "message":\n f"Database error:\n {str(e)}",            }        # 2. Verificar configuraci√≥n JWT        jwt_ok = bool(settings.SECRET_KEY and len(settings.SECRET_KEY) >= 32)        checks["jwt_config"] = {            "status":\n "healthy" if jwt_ok else "unhealthy",            "message":\n (                "JWT configuration OK"                if jwt_ok                else "JWT configuration issues"            ),            "secret_key_length":\n (                len(settings.SECRET_KEY) if settings.SECRET_KEY else 0            ),        }        # 3. Verificar usuarios admin        try:\n            admin_count = db.query(User).filter(User.is_admin).count()            admin_ok = admin_count > 0            checks["admin_users"] = {                "status":\n "healthy" if admin_ok else "unhealthy",                "message":\n (                    f"Found {admin_count} admin users"                    if admin_ok                    else "No admin users found"                ),                "count":\n admin_count,            }        except Exception as e:\n            checks["admin_users"] = {                "status":\n "unhealthy",                "message":\n f"Error checking admin users:\n {str(e)}",            }        # 4. Verificar logs de auditor√≠a        recent_logs = AuditLogger.get_recent_logs(5)  # √öltimos 5 minutos        error_rate = len(            [log for log in recent_logs if log["status_code"] >= 400]        ) / max(len(recent_logs), 1)        checks["audit_logs"] = {            "status":\n "healthy" if error_rate < 0.5 else "warning",            "message":\n f"Error rate:\n {error_rate:\n.2%}",            "recent_requests":\n len(recent_logs),            "error_rate":\n error_rate,        }        # Estado general        overall_status = "healthy"        if any(check["status"] == "unhealthy" for check in checks.values()):\n            overall_status = "unhealthy"        elif any(check["status"] == "warning" for check in checks.values()):\n            overall_status = "warning"        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n overall_status,            "checks":\n checks,            "summary":\n {                "total_checks":\n len(checks),                "healthy_checks":\n len(                    [c for c in checks.values() if c["status"] == "healthy"]                ),                "warning_checks":\n len(                    [c for c in checks.values() if c["status"] == "warning"]                ),                "unhealthy_checks":\n len(                    [c for c in checks.values() if c["status"] == "unhealthy"]                ),            },        }    except Exception as e:\n        logger.error(f"Error en health check detallado:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/clear-logs")async \ndef limpiar_logs_auditoria():\n    """    üßπ Limpiar logs de auditor√≠a    """    try:\n        # Limpiar logs        audit_logs.clear()        error_patterns.clear()        request_stats.clear()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "message":\n "Audit logs cleared successfully",        }    except Exception as e:\n        logger.error(f"Error limpiando logs:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }\ndef _generate_dashboard_recommendations(    auth_analysis:\n Dict, user_stats:\n Dict) -> List[str]:\n    """Generar recomendaciones basadas en el an√°lisis del dashboard"""    recommendations = []    # An√°lisis de tasa de error    error_rate = auth_analysis.get("error_rate", 0)    if error_rate > 50:\n        recommendations.append(            "üö® Tasa de error muy alta (>50%) - Revisar configuraci√≥n de \            autenticaci√≥n"        )    elif error_rate > 20:\n        recommendations.append(            "‚ö†Ô∏è Tasa de error elevada (>20%) -     Monitorear logs de autenticaci√≥n"        )    # An√°lisis de usuarios    if user_stats.get("admin_users", 0) == 0:\n        recommendations.append(            "üë§ No hay usuarios administradores - Crear usuario admin"        )    if user_stats.get("active_users", 0) == 0:\n        recommendations.append(            "‚ö†Ô∏è No hay usuarios activos - Verificar estado de usuarios"        )    # Recomendaciones generales    if not recommendations:\n        recommendations.append("‚úÖ Sistema funcionando correctamente")    return recommendations# Nota:\n Middleware removido - APIRouter no soporta middleware directamente# El middleware debe ser agregado a la aplicaci√≥n principal en main.py
