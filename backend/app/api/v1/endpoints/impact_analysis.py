"""Endpoint de Análisis de Impacto en PerformanceProporciona métricas y análisis de impacto del sistema"""\nimport logging\nimport time\nfrom typing \nimport Any, Dict\nfrom fastapi \nimport APIRouter, Depends, HTTPException, status\nfrom app.api.deps \nimport get_current_user\nfrom app.core.impact_monitoring \nimport get_impact_analyzer\nfrom app.core.error_impact_analysis \nimport get_error_analyzer\nfrom app.models.user \nimport Userrouter = APIRouter()logger = logging.getLogger(__name__)@router.get("/health", response_model=Dict[str, Any])async \ndef get_health_impact_analysis_public():\n    """    Obtener análisis de impacto de health checks (PÚBLICO)    - Métricas de performance de health checks    - Impacto en recursos del sistema    - Alertas y recomendaciones    """    try:\n        analyzer = get_impact_analyzer()        status_data = analyzer.get_current_status()        return {            "status":\n "success",            "data":\n status_data,            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error obteniendo análisis de health:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error obteniendo análisis de health:\n {str(e)}",        )@router.get("/impact/health", response_model=Dict[str, Any])async \ndef get_health_impact_analysis(    current_user:\n User = Depends(get_current_user),):\n    """    Obtener análisis de impacto de health checks    - Métricas de performance de health checks    - Impacto en recursos del sistema    - Alertas y recomendaciones    """    try:\n        analyzer = get_impact_analyzer()        status_data = analyzer.get_current_status()        return {            "status":\n "success",            "data":\n status_data,            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error obteniendo análisis de health:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error obteniendo análisis de health:\n {str(e)}",        )@router.get("/impact/performance", response_model=Dict[str, Any])async \ndef get_performance_impact_analysis(    current_user:\n User = Depends(get_current_user),):\n    """    Obtener análisis de impacto en performance    - Métricas de performance de endpoints    - Análisis de impacto en recursos    - Recomendaciones de optimización    """    try:\n        analyzer = get_impact_analyzer()        report = analyzer.get_performance_report()        return {"status":\n "success", "data":\n report, "timestamp":\n time.time()}    except Exception as e:\n        logger.error(f"Error obteniendo análisis de performance:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error obteniendo análisis de performance:\n {str(e)}",        )@router.get("/impact/errors", response_model=Dict[str, Any])async \ndef get_error_impact_analysis(    current_user:\n User = Depends(get_current_user),):\n    """    Obtener análisis de impacto de errores    - Tasa de error del sistema    - Análisis de impacto de errores    - Estado de circuit breakers    - Recomendaciones de manejo de errores    """    try:\n        analyzer = get_error_analyzer()        analysis = analyzer.get_error_impact_analysis()        summary = analyzer.get_endpoint_error_summary()        recent_errors = analyzer.get_recent_errors(limit=10)        return {            "status":\n "success",            "data":\n {                "impact_analysis":\n analysis.__dict__,                "endpoint_summary":\n summary,                "recent_errors":\n recent_errors,            },            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error obteniendo análisis de errores:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error obteniendo análisis de errores:\n {str(e)}",        )@router.get("/impact/comprehensive", response_model=Dict[str, Any])async \ndef get_comprehensive_impact_analysis(    current_user:\n User = Depends(get_current_user),):\n    """    Obtener análisis integral de impacto del sistema    - Health checks impact    - Performance impact    - Error impact    - System recommendations    """    try:\n        # Obtener análisis de cada componente        health_analyzer = get_impact_analyzer()        error_analyzer = get_error_analyzer()        health_status = health_analyzer.get_current_status()        performance_report = health_analyzer.get_performance_report()        error_analysis = error_analyzer.get_error_impact_analysis()        error_summary = error_analyzer.get_endpoint_error_summary()        # Calcular score general del sistema        system_score = _calculate_system_score(            health_status, performance_report, error_analysis        )        # Generar recomendaciones generales        general_recommendations = _generate_general_recommendations(            health_status, performance_report, error_analysis        )        return {            "status":\n "success",            "data":\n {                "system_score":\n system_score,                "health_analysis":\n health_status,                "performance_analysis":\n performance_report,                "error_analysis":\n {                    "impact_analysis":\n error_analysis.__dict__,                    "endpoint_summary":\n error_summary,                },                "general_recommendations":\n general_recommendations,                "analysis_timestamp":\n time.time(),            },            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error obteniendo análisis integral:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error obteniendo análisis integral:\n {str(e)}",        )@router.post("/impact/monitoring/start")async \ndef start_impact_monitoring(    current_user:\n User = Depends(get_current_user),):\n    """    Iniciar monitoreo de impacto del sistema    Requiere permisos de administrador    """    if not current_user.is_admin:\n        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Se requieren permisos de administrador",        )    try:\n        analyzer = get_impact_analyzer()        analyzer.start_monitoring()        return {            "status":\n "success",            "message":\n "Monitoreo de impacto iniciado",            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error iniciando monitoreo:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error iniciando monitoreo:\n {str(e)}",        )@router.post("/impact/monitoring/stop")async \ndef stop_impact_monitoring(    current_user:\n User = Depends(get_current_user),):\n    """    Detener monitoreo de impacto del sistema    Requiere permisos de administrador    """    if not current_user.is_admin:\n        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Se requieren permisos de administrador",        )    try:\n        analyzer = get_impact_analyzer()        analyzer.stop_monitoring()        return {            "status":\n "success",            "message":\n "Monitoreo de impacto detenido",            "timestamp":\n time.time(),        }    except Exception as e:\n        logger.error(f"Error deteniendo monitoreo:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error deteniendo monitoreo:\n {str(e)}",        )\ndef _calculate_system_score(    health_status:\n Dict, performance_report:\n Dict, error_analysis:\n Any) -> Dict[str, Any]:\n    """Calcular score general del sistema"""    score = 100    # Penalizar por alertas de health    if health_status.get("active_alerts", 0) > 0:\n        score -= health_status["active_alerts"] * 10    # Penalizar por performance    if (        performance_report.get("performance_summary", {}).get(            "avg_response_time_ms", 0        )        > 500    ):\n        score -= 20    # Penalizar por tasa de error    if error_analysis.error_rate > 0.05:\n  # 5%        score -= error_analysis.error_rate * 200    # Penalizar por errores consecutivos    if error_analysis.consecutive_errors > 3:\n        score -= error_analysis.consecutive_errors * 5    score = max(0, min(100, score))    # Determinar nivel    if score >= 90:\n        level = "EXCELLENT"    elif score >= 80:\n        level = "GOOD"    elif score >= 70:\n        level = "FAIR"    elif score >= 60:\n        level = "POOR"    else:\n        level = "CRITICAL"    return {        "score":\n score,        "level":\n level,        "factors":\n {            "health_alerts":\n health_status.get("active_alerts", 0),            "avg_response_time":\n (                performance_report.get("performance_summary", {}).get(                    "avg_response_time_ms", 0                )            ),            "error_rate":\n error_analysis.error_rate,            "consecutive_errors":\n error_analysis.consecutive_errors,        },    }\ndef _generate_general_recommendations(    health_status:\n Dict, performance_report:\n Dict, error_analysis:\n Any) -> list:\n    """Generar recomendaciones generales del sistema"""    recommendations = []    # Recomendaciones basadas en health    if health_status.get("active_alerts", 0) > 0:\n        recommendations.append("Revisar alertas activas del sistema")    # Recomendaciones basadas en performance    avg_response_time = performance_report.get("performance_summary", {}).get(        "avg_response_time_ms", 0    )    if avg_response_time > 1000:\n        recommendations.append(            "Optimizar endpoints con tiempo de respuesta > 1s"        )    # Recomendaciones basadas en errores    if error_analysis.error_rate > 0.05:\n        recommendations.append("Implementar manejo de errores más robusto")    if error_analysis.consecutive_errors > 3:\n        recommendations.append(            "Activar circuit breakers para endpoints problemáticos"        )    if not recommendations:\n        recommendations.append(            "Sistema funcionando dentro de parámetros normales"        )    return recommendations
