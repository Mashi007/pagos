"""Sistema de Validación Cruzada de AutenticaciónValida tokens desde múltiples perspectivas para detectar inconsistencias"""\nimport hashlib\nimport logging\nfrom collections \nimport defaultdict\nfrom datetime \nimport datetime\nfrom typing \nimport Any, Dict\nfrom fastapi \nimport APIRouter, Depends, HTTPException, Request\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.core.security \nimport create_access_token, decode_token\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE VALIDACIÓN CRUZADA# ============================================\nclass CrossValidationAuthChecker:\n    """Validador cruzado de autenticación"""    \ndef __init__(self):\n        self.validation_cache = {}  # Cache de validaciones        self.failed_validations = defaultdict(list)  # Historial de fallos        self.validation_patterns = defaultdict(int)  # Patrones de validación    \ndef cross_validate_token(        self, token:\n str, request_context:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Validación cruzada completa de un token"""        validation_results = {            "timestamp":\n datetime.now().isoformat(),            "token_id":\n self._generate_token_id(token),            "validations":\n {},            "overall_status":\n "unknown",            "confidence_score":\n 0.0,            "recommendations":\n [],        }        try:\n            # 1. Validación básica de JWT            jwt_validation = self._validate_jwt_structure(token)            validation_results["validations"]["jwt_structure"] = jwt_validation            # 2. Validación de contenido            content_validation = self._validate_token_content(token)            validation_results["validations"][                "token_content"            ] = content_validation            # 3. Validación de contexto            context_validation = self._validate_request_context(                token, request_context            )            validation_results["validations"][                "request_context"            ] = context_validation            # 4. Validación de tiempo            time_validation = self._validate_timing(token)            validation_results["validations"]["timing"] = time_validation            # 5. Validación de usuario            user_validation = self._validate_user_consistency(                token, request_context            )            validation_results["validations"][                "user_consistency"            ] = user_validation            # 6. Validación de seguridad            security_validation = self._validate_security_patterns(                token, request_context            )            validation_results["validations"][                "security_patterns"            ] = security_validation            # Calcular resultado general            validation_results = self._calculate_overall_result(                validation_results            )            # Cachear resultado            self.validation_cache[validation_results["token_id"]] = (                validation_results            )            return validation_results        except Exception as e:\n            logger.error(f"Error en validación cruzada:\n {e}")            validation_results["overall_status"] = "error"            validation_results["error"] = str(e)            return validation_results    \ndef _generate_token_id(self, token:\n str) -> str:\n        """Generar ID único para el token"""        return hashlib.sha256(token.encode()).hexdigest()[:\n16]    \ndef _validate_jwt_structure(self, token:\n str) -> Dict[str, Any]:\n        """Validar estructura básica del JWT"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            # Verificar formato básico (3 partes separadas por puntos)            parts = token.split(".")            if len(parts) != 3:\n                validation["status"] = "invalid"                validation["details"]["error"] = "Formato JWT inválido"                return validation            # Verificar que cada parte sea base64 válido            for i, part in enumerate(parts):\n                try:\n                    \nimport base64                    base64.urlsafe_b64decode(                        part + "=="                    )  # Padding para base64                except Exception:\n                    validation["status"] = "invalid"                    validation["details"][                        "error"                    ] = f"Parte {i + 1} no es base64 válido"                    return validation            # Intentar decodificar el payload            try:\n                payload = decode_token(token)                validation["status"] = "valid"                validation["details"]["payload_keys"] = list(payload.keys())                validation["score"] = 1.0            except Exception as e:\n                validation["status"] = "invalid"                validation["details"]["error"] = str(e)                validation["score"] = 0.0            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _validate_token_content(self, token:\n str) -> Dict[str, Any]:\n        """Validar contenido del token"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            payload = decode_token(token)            # Verificar campos requeridos            required_fields = ["sub", "exp", "type"]            missing_fields = [                field for field in required_fields if field not in payload            ]            if missing_fields:\n                validation["status"] = "invalid"                validation["details"]["missing_fields"] = missing_fields                validation["score"] = 0.0                return validation            # Verificar tipo de token            if payload.get("type") != "access":\n                validation["status"] = "invalid"                validation["details"][                    "error"                ] = f'Tipo de token incorrecto:\n {payload.get("type")}'                validation["score"] = 0.0                return validation            # Verificar formato de user_id            user_id = payload.get("sub")            if not user_id or not str(user_id).isdigit():\n                validation["status"] = "invalid"                validation["details"]["error"] = "User ID inválido"                validation["score"] = 0.0                return validation            # Verificar tiempo de expiración            exp_time = datetime.fromtimestamp(payload.get("exp", 0))            current_time = datetime.now()            if exp_time < current_time:\n                validation["status"] = "expired"                validation["details"]["expired_at"] = exp_time.isoformat()                validation["score"] = 0.0            else:\n                time_to_expiry = (exp_time - current_time).total_seconds()                validation["status"] = "valid"                validation["details"]["expires_at"] = exp_time.isoformat()                validation["details"]["time_to_expiry_minutes"] = int(                    time_to_expiry / 60                )                validation["score"] = 1.0            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _validate_request_context(        self, token:\n str, context:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Validar contexto de la request"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            payload = decode_token(token)            payload.get("sub")            # Verificar que el endpoint sea apropiado para el usuario            endpoint = context.get("endpoint", "")            context.get("method", "")            # Reglas de validación de contexto            context_rules = {                "admin_endpoints":\n [                    "/api/v1/usuarios",                    "/api/v1/configuracion",                ],                "user_endpoints":\n ["/api/v1/clientes", "/api/v1/prestamos"],                "public_endpoints":\n [                    "/api/v1/auth/login",                    "/api/v1/auth/refresh",                ],            }            # Verificar si el endpoint requiere admin            is_admin_endpoint = any(                admin_ep in endpoint                for admin_ep in context_rules["admin_endpoints"]            )            is_user_endpoint = any(                user_ep in endpoint                for user_ep in context_rules["user_endpoints"]            )            if is_admin_endpoint:\n                # Verificar si el token tiene claims de admin                is_admin = payload.get("is_admin", False)                if not is_admin:\n                    validation["status"] = "insufficient_privileges"                    validation["details"][                        "error"                    ] = "Endpoint requiere privilegios de admin"                    validation["score"] = 0.0                    return validation            # Verificar IP y User-Agent (básico)            client_ip = context.get("client_ip", "")            context.get("user_agent", "")            validation["status"] = "valid"            validation["details"]["endpoint_type"] = (                "admin"                if is_admin_endpoint                else "user" if is_user_endpoint else "public"            )            validation["details"]["client_ip"] = client_ip            validation["score"] = 1.0            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _validate_timing(self, token:\n str) -> Dict[str, Any]:\n        """Validar aspectos temporales del token"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            payload = decode_token(token)            # Verificar tiempo de emisión            iat = payload.get("iat", 0)            if iat:\n                issued_time = datetime.fromtimestamp(iat)                current_time = datetime.now()                # El token no puede ser del futuro                if issued_time > current_time:\n                    validation["status"] = "invalid"                    validation["details"][                        "error"                    ] = "Token emitido en el futuro"                    validation["score"] = 0.0                    return validation                # El token no puede ser muy antiguo (más de 24 horas)                age_hours = (current_time - issued_time).total_seconds() / 3600                if age_hours > 24:\n                    validation["status"] = "suspicious"                    validation["details"][                        "warning"                    ] = f"Token muy antiguo:\n {age_hours:\n.1f} horas"                    validation["score"] = 0.5                else:\n                    validation["status"] = "valid"                    validation["details"]["age_hours"] = age_hours                    validation["score"] = 1.0            else:\n                validation["status"] = "valid"                validation["score"] = 0.8  # Sin iat, pero no es crítico            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _validate_user_consistency(        self, token:\n str, context:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Validar consistencia del usuario"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            payload = decode_token(token)            user_id = payload.get("sub")            # Verificar que el user_id sea consistente            if not user_id:\n                validation["status"] = "invalid"                validation["details"]["error"] = "User ID faltante"                validation["score"] = 0.0                return validation            # Verificar formato del email si está presente            email = payload.get("email", "")            if email and "@" not in email:\n                validation["status"] = "invalid"                validation["details"]["error"] = "Email inválido en token"                validation["score"] = 0.0                return validation            validation["status"] = "valid"            validation["details"]["user_id"] = user_id            validation["details"]["email"] = email            validation["score"] = 1.0            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _validate_security_patterns(        self, token:\n str, context:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Validar patrones de seguridad"""        validation = {"status":\n "unknown", "details":\n {}, "score":\n 0.0}        try:\n            payload = decode_token(token)            # Verificar que no sea un token de prueba/test            if "test" in str(payload.get("sub", "")).lower():\n                validation["status"] = "suspicious"                validation["details"]["warning"] = "Token de prueba detectado"                validation["score"] = 0.3                return validation            # Verificar patrones sospechosos en el token            token_str = str(token)            suspicious_patterns = ["admin", "root", "test", "demo"]            for pattern in suspicious_patterns:\n                if pattern in token_str.lower():\n                    validation["status"] = "suspicious"                    validation["details"][                        "warning"                    ] = f"Patrón sospechoso detectado:\n {pattern}"                    validation["score"] = 0.5                    return validation            validation["status"] = "valid"            validation["score"] = 1.0            return validation        except Exception as e:\n            validation["status"] = "error"            validation["details"]["error"] = str(e)            return validation    \ndef _calculate_overall_result(        self, validation_results:\n Dict[str, Any]    ) -> Dict[str, Any]:\n        """Calcular resultado general de la validación"""        validations = validation_results["validations"]        # Calcular score promedio        scores = [v.get("score", 0.0) for v in validations.values()]        avg_score = sum(scores) / len(scores) if scores else 0.0        # Determinar estado general        failed_validations = [            k            for k, v in validations.items()            if v.get("status") in ["invalid", "error"]        ]        suspicious_validations = [            k            for k, v in validations.items()            if v.get("status") == "suspicious"        ]        if failed_validations:\n            overall_status = "failed"        elif suspicious_validations:\n            overall_status = "suspicious"        elif avg_score >= 0.8:\n            overall_status = "valid"        else:\n            overall_status = "warning"        # Generar recomendaciones        recommendations = []        if "jwt_structure" in failed_validations:\n            recommendations.append("Token JWT malformado - regenerar token")        if "token_content" in failed_validations:\n            recommendations.append(                "Contenido del token inválido - verificar configuración"            )        if "timing" in failed_validations:\n            recommendations.append(                "Problema temporal - verificar sincronización de reloj"            )        if "user_consistency" in failed_validations:\n            recommendations.append(                "Inconsistencia de usuario - verificar datos"            )        if "security_patterns" in suspicious_validations:\n            recommendations.append("Patrones sospechosos - revisar seguridad")        if not recommendations:\n            recommendations.append("Token válido - no se requieren acciones")        validation_results["overall_status"] = overall_status        validation_results["confidence_score"] = avg_score        validation_results["recommendations"] = recommendations        return validation_results# Instancia global del validadorcross_validator = CrossValidationAuthChecker()# ============================================# ENDPOINTS DE VALIDACIÓN CRUZADA# ============================================@router.post("/cross-validate")async \ndef cross_validate_token_endpoint(    request:\n Request,    token_data:\n Dict[str, str],    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    🔄 Validación cruzada completa de un token    """    try:\n        token = token_data.get("token")        if not token:\n            raise HTTPException(status_code=400, detail="Token requerido")        # Construir contexto de la request        request_context = {            "endpoint":\n str(request.url.path),            "method":\n request.method,            "client_ip":\n request.client.host,            "user_agent":\n request.headers.get("user-agent", ""),            "timestamp":\n datetime.now().isoformat(),        }        # Realizar validación cruzada        validation_result = cross_validator.cross_validate_token(            token, request_context        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "validation":\n validation_result,        }    except HTTPException:\n        raise    except Exception as e:\n        logger.error(f"Error en validación cruzada:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/validation-history")async \ndef get_validation_history(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    📊 Historial de validaciones cruzadas    """    try:\n        # Obtener estadísticas de validación        total_validations = len(cross_validator.validation_cache)        failed_validations = len(cross_validator.failed_validations)        # Patrones más comunes        common_patterns = dict(cross_validator.validation_patterns)        sorted_patterns = sorted(            common_patterns.items(), key=lambda x:\n x[1], reverse=True        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "statistics":\n {                "total_validations":\n total_validations,                "failed_validations":\n failed_validations,                "success_rate":\n (                    (                        (total_validations - failed_validations)                        / total_validations                        * 100                    )                    if total_validations > 0                    else 100                ),                "common_patterns":\n sorted_patterns[:\n10],            },            "recent_validations":\n list(                cross_validator.validation_cache.values()            )[                -10:\n            ],  # Últimas 10        }    except Exception as e:\n        logger.error(f"Error obteniendo historial de validación:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/validate-user-token")async \ndef validate_user_token_comprehensive(    user_id:\n int,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    👤 Validación cruzada completa para un usuario específico    """    try:\n        # Verificar que el usuario existe        user = db.query(User).filter(User.id == user_id).first()        if not user:\n            raise HTTPException(                status_code=404, detail="Usuario no encontrado"            )        # Generar token de prueba para validación        test_token = create_access_token(            subject=str(user.id),            additional_claims={                "type":\n "access",                "email":\n user.email,                "is_admin":\n user.is_admin,            },        )        # Contexto de prueba        test_context = {            "endpoint":\n "/api/v1/test",            "method":\n "GET",            "client_ip":\n "127.0.0.1",            "user_agent":\n "Test Agent",            "timestamp":\n datetime.now().isoformat(),        }        # Realizar validación cruzada        validation_result = cross_validator.cross_validate_token(            test_token, test_context        )        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "user":\n {                "id":\n user.id,                "email":\n user.email,                "is_active":\n user.is_admin,            },            "validation":\n validation_result,        }    except HTTPException:\n        raise    except Exception as e:\n        logger.error(f"Error validando token del usuario:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
