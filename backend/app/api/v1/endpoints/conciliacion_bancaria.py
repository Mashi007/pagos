\nimport io\nimport logging\nfrom datetime \nimport datetime\nimport pandas as pd\nfrom fastapi \nimport APIRouter, Depends, File, HTTPException, UploadFile, status\nfrom sqlalchemy \nimport and_\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.pago \nimport Pago\nfrom app.models.user \nimport User\nfrom app.schemas.conciliacion \nimport ConciliacionCreate, ConciliacionResponselogger = logging.getLogger(__name__)router = APIRouter()@router.get("/template-conciliacion")async \ndef generar_template_conciliacion(    current_user:\n User = Depends(get_current_user),):\n    """Generar template Excel para conciliación bancaria"""    try:\n        logger.info(            f"Usuario {current_user.email} generando template de conciliación"        )        # Crear workbook        \nfrom openpyxl \nimport Workbook        \nfrom openpyxl.worksheet.datavalidation \nimport DataValidation        wb = Workbook()        # HOJA 1:\n INSTRUCCIONES        ws_instrucciones = wb.active        ws_instrucciones.title = "Instrucciones"        instrucciones = [            ["INSTRUCCIONES PARA CONCILIACIÓN BANCARIA"],            [""],            ["1. FORMATO DE ARCHIVO:\n"],            ["   - Archivo Excel (.xlsx)"],            ["   - Primera fila:\n encabezados de columnas"],            ["   - Datos desde la segunda fila"],            ["   - Máximo 100 registros por archivo"],            [""],            ["2. COLUMNAS REQUERIDAS:\n"],            ["   - fecha:\n Fecha real del pago (formato YYYY-MM-DD)"],            ["   - numero_documento:\n Número de documento del pago"],            [""],            ["3. PROCESO DE CONCILIACIÓN:\n"],            [                "   - El sistema compara el número de documento con la \                base de datos"            ],            ["   - Si hay coincidencia EXACTA:\n se marca como CONCILIADO"],            ["   - Si NO hay coincidencia:\n se marca como PENDIENTE"],            [""],            ["4. VALIDACIONES:\n"],            ["   - Fecha debe estar en formato YYYY-MM-DD"],            ["   - Número de documento debe coincidir EXACTAMENTE"],            ["   - No se permiten caracteres especiales adicionales"],            [""],            ["5. EJEMPLOS DE DATOS VÁLIDOS:\n"],            ["   - fecha:\n '2024-01-15'"],            ["   - numero_documento:\n 'DOC001234'"],            [""],            ["6. NOTAS IMPORTANTES:\n"],            ["   - No eliminar las columnas"],            ["   - No cambiar el orden de las columnas"],            ["   - Usar solo caracteres ASCII"],            ["   - Verificar que los números de documento sean exactos"],            ["   - Un archivo por vez"],            [""],            ["7. RESULTADO:\n"],            ["   - Los pagos conciliados aparecerán en el resumen"],            ["   - Los pendientes requerirán revisión manual"],            [""],            ["8. DESCONCILIACIÓN:\n"],            ["   - Se puede desconciliar un pago ya conciliado"],            ["   - Requiere formulario con justificación"],            ["   - Se registra en auditoría"],            [""],            [                "FECHA DE GENERACIÓN:\n "                + datetime.now().strftime("%Y-%m-%d %H:\n%M:\n%S")            ],            ["GENERADO POR:\n " + current_user.email],        ]        # Agregar instrucciones a la hoja        for i, instruccion in enumerate(instrucciones, 1):\n            ws_instrucciones.cell(row=i, column=1, value=instruccion[0])        # HOJA 2:\n TEMPLATE VACÍA        ws_template = wb.create_sheet("Template_Conciliacion")        # Encabezados        encabezados = ["fecha", "numero_documento"]        for i, encabezado in enumerate(encabezados, 1):\n            ws_template.cell(row=1, column=i, value=encabezado)        # Ejemplo de datos        ejemplo = ["2024-01-15", "DOC001234"]        for i, valor in enumerate(ejemplo, 1):\n            ws_template.cell(row=2, column=i, value=valor)        # Aplicar validaciones        # Validación para fecha (formato YYYY-MM-DD)        dv_fecha = DataValidation(            type="date", formula1="2020-01-01", formula2="2030-12-31"        )        dv_fecha.add("A2:\nA100")        ws_template.add_data_validation(dv_fecha)        # Guardar en memoria        output = io.BytesIO()        wb.save(output)        output.seek(0)        logger.info("Template de conciliación generado exitosamente")        return {            "success":\n True,            "message":\n "Template generado exitosamente",            "filename":\n f"Template_Conciliacion_{datetime.now().strftime \            ('%Y%m%d_%H%M%S')}.xlsx",            "content":\n output.getvalue(),        }    except Exception as e:\n        logger.error(f"Error generando template de conciliación:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error interno del servidor:\n {str(e)}",        )@router.post("/procesar-conciliacion")async \ndef procesar_conciliacion(    file:\n UploadFile = File(...),    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """Procesar archivo Excel de conciliación bancaria"""    try:\n        logger.info(            f"Usuario {current_user.email} procesando conciliación bancaria"        )        # Validar tipo de archivo        if not file.filename.endswith((".xlsx", ".xls")):\n            raise HTTPException(                status_code=status.HTTP_400_BAD_REQUEST,                detail="Archivo debe ser Excel (.xlsx o .xls)",            )        # Leer archivo Excel        file_content = await file.read()        df = pd.read_excel(            io.BytesIO(file_content), sheet_name=1        )  # Segunda hoja        # Validar columnas requeridas        required_columns = ["fecha", "numero_documento"]        if not all(col in df.columns for col in required_columns):\n            raise HTTPException(                status_code=status.HTTP_400_BAD_REQUEST,                detail=f"Columnas requeridas:\n {required_columns}",            )        # Validar límite de registros        if len(df) > 100:\n            raise HTTPException(                status_code=status.HTTP_400_BAD_REQUEST,                detail="Máximo 100 registros por archivo",            )        # Procesar cada registro        resultados = []        conciliados = 0        pendientes = 0        for index, row in df.iterrows():\n            fecha = row["fecha"]            numero_documento = str(row["numero_documento"]).strip()            # Buscar pago en BD            pago = (                db.query(Pago)                .filter(                    and_(                        Pago.activo, Pago.numero_documento == numero_documento                    )                )                .first()            )            if pago:\n                # Marcar como conciliado                pago.conciliado = True                pago.fecha_conciliacion = datetime.now()                conciliados += 1                estado = "CONCILIADO"            else:\n                pendientes += 1                estado = "PENDIENTE"            resultados.append(                {                    "fila":\n index                    +     2,  # +2 porque Excel es 1-indexed y primera fila es encabezado                    "fecha":\n str(fecha),                    "numero_documento":\n numero_documento,                    "estado":\n estado,                    "pago_id":\n pago.id if pago else None,                }            )        # Guardar cambios        db.commit()        logger.info(            f"Conciliación procesada:\n {conciliados} "    f"conciliados, {pendientes} pendientes"        )        return {            "success":\n True,            "message":\n "Conciliación procesada exitosamente",            "resumen":\n {                "total_registros":\n len(df),                "conciliados":\n conciliados,                "pendientes":\n pendientes,            },            "resultados":\n resultados,        }    except HTTPException:\n        raise    except Exception as e:\n        db.rollback()        logger.error(f"Error procesando conciliación:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error interno del servidor:\n {str(e)}",        )@router.post(    "/desconciliar-pago",    response_model=ConciliacionResponse,    status_code=status.HTTP_201_CREATED,)async \ndef desconciliar_pago(    conciliacion_data:\n ConciliacionCreate,    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """Desconciliar un pago ya conciliado"""    try:\n        logger.info(            f"Usuario {current_user.email} desconciliando pago "    f"{conciliacion_data.numero_documento_anterior}"        )        # Buscar el pago a desconciliar        pago = (            db.query(Pago)            .filter(                and_(                    Pago.activo,                    Pago.numero_documento                    == conciliacion_data.numero_documento_anterior,                    Pago.conciliado,                )            )            .first()        )        if not pago:\n            raise HTTPException(                status_code=status.HTTP_404_NOT_FOUND,                detail="Pago no encontrado o no está conciliado",            )        # Desconciliar el pago        pago.conciliado = False        pago.fecha_conciliacion = None        # Crear registro de auditoría (simulado - se integrará con módulo de        # auditoría)        conciliacion_record = {            "id":\n len(db.query(Pago).all()) + 1,  # ID temporal            "cedula_cliente":\n conciliacion_data.cedula_cliente,            "numero_documento_anterior":\n    conciliacion_data.numero_documento_anterior,            "numero_documento_nuevo":\n conciliacion_data.numero_documento_nuevo,            "cedula_nueva":\n conciliacion_data.cedula_nueva,            "nota":\n conciliacion_data.nota,            "fecha":\n datetime.now(),            "responsable":\n current_user.email,            "pago_id":\n pago.id,        }        db.commit()        logger.info(            f"Pago {conciliacion_data.numero_documento_anterior} "    f"desconciliado exitosamente"        )        return conciliacion_record    except HTTPException:\n        raise    except Exception as e:\n        db.rollback()        logger.error(f"Error desconciliando pago:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error interno del servidor:\n {str(e)}",        )@router.get("/estado-conciliacion")async \ndef obtener_estado_conciliacion(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """Obtener estado general de conciliación"""    try:\n        # Estadísticas generales        total_pagos = db.query(Pago).filter(Pago.activo).count()        pagos_conciliados = (            db.query(Pago).filter(and_(Pago.activo, Pago.conciliado)).count()        )        pagos_pendientes = total_pagos - pagos_conciliados        # Porcentaje de conciliación        porcentaje_conciliacion = (            (pagos_conciliados / total_pagos * 100) if total_pagos > 0 else 0        )        return {            "success":\n True,            "estadisticas":\n {                "total_pagos":\n total_pagos,                "pagos_conciliados":\n pagos_conciliados,                "pagos_pendientes":\n pagos_pendientes,                "porcentaje_conciliacion":\n round(porcentaje_conciliacion, 2),            },            "fecha_actualizacion":\n datetime.now(),        }    except Exception as e:\n        logger.error(f"Error obteniendo estado de conciliación:\n {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=f"Error interno del servidor:\n {str(e)}",        )
