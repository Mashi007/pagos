"""Sistema de Diagnóstico de Red y LatenciaAnaliza problemas de conectividad y rendimiento de red"""\nimport logging\nimport socket\nimport statistics\nimport threading\nimport time\nimport urllib.request\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE DIAGNÓSTICO DE RED# ============================================\nclass NetworkDiagnosticSystem:\n    """Sistema de diagnóstico de red y latencia"""    \ndef __init__(self):\n        self.latency_history = deque(maxlen=1000)  # Historial de latencia        self.connection_tests = deque(maxlen=100)  # Tests de conexión        self.network_metrics = defaultdict(list)  # Métricas de red        self.lock = threading.Lock()        # Iniciar monitoreo en background        self._start_background_monitoring()    \ndef _start_background_monitoring(self):\n        """Iniciar monitoreo de red en background"""        \ndef monitoring_loop():\n            while True:\n                try:\n                    self._perform_network_tests()                    time.sleep(60)  # Test cada minuto                except Exception as e:\n                    logger.error(f"Error en monitoreo de red:\n {e}")                    time.sleep(120)        thread = threading.Thread(target=monitoring_loop, daemon=True)        thread.start()        logger.info("🌐 Sistema de diagnóstico de red iniciado")    \ndef _perform_network_tests(self):\n        """Realizar tests de red periódicos"""        with self.lock:\n            # Test de conectividad básica            connectivity_test = self._test_connectivity()            self.connection_tests.append(connectivity_test)            # Test de latencia a servicios externos            latency_tests = self._test_latency()            for test in latency_tests:\n                self.latency_history.append(test)    \ndef _test_connectivity(self) -> Dict[str, Any]:\n        """Test básico de conectividad"""        test_result = {            "timestamp":\n datetime.now().isoformat(),            "tests":\n {},            "overall_status":\n "unknown",        }        # Test de DNS        try:\n            socket.gethostbyname("google.com")            test_result["tests"]["dns"] = {                "status":\n "success",                "latency_ms":\n 0,            }        except Exception as e:\n            test_result["tests"]["dns"] = {"status":\n "failed", "error":\n str(e)}        # Test de conectividad HTTP        try:\n            \nimport urllib.request            start_time = time.time()            urllib.request.urlopen("http:\n//httpbin.org/get", timeout=10)            latency = (time.time() - start_time) * 1000            test_result["tests"]["http"] = {                "status":\n "success",                "latency_ms":\n latency,            }        except Exception as e:\n            test_result["tests"]["http"] = {                "status":\n "failed",                "error":\n str(e),            }        # Test de conectividad HTTPS        try:\n            start_time = time.time()            urllib.request.urlopen("https:\n//httpbin.org/get", timeout=10)            latency = (time.time() - start_time) * 1000            test_result["tests"]["https"] = {                "status":\n "success",                "latency_ms":\n latency,            }        except Exception as e:\n            test_result["tests"]["https"] = {                "status":\n "failed",                "error":\n str(e),            }        # Determinar estado general        failed_tests = [            test            for test in test_result["tests"].values()            if test["status"] == "failed"        ]        if len(failed_tests) == 0:\n            test_result["overall_status"] = "excellent"        elif len(failed_tests) == 1:\n            test_result["overall_status"] = "good"        elif len(failed_tests) == 2:\n            test_result["overall_status"] = "degraded"        else:\n            test_result["overall_status"] = "poor"        return test_result    \ndef _test_latency(self) -> List[Dict[str, Any]]:\n        """Test de latencia a varios servicios"""        latency_tests = []        # Servicios a testear        services = [            {"name":\n "google_dns", "host":\n "8.8.8.8", "port":\n 53},            {"name":\n "cloudflare_dns", "host":\n "1.1.1.1", "port":\n 53},            {"name":\n "google_http", "url":\n "https:\n//www.google.com"},            {"name":\n "cloudflare_http", "url":\n "https:\n//www.cloudflare.com"},        ]        for service in services:\n            test_result = {                "service":\n service["name"],                "timestamp":\n datetime.now().isoformat(),                "latency_ms":\n None,                "status":\n "unknown",                "error":\n None,            }            try:\n                if "url" in service:\n                    # Test HTTP/HTTPS                    start_time = time.time()                    urllib.request.urlopen(service["url"], timeout=10)                    latency = (time.time() - start_time) * 1000                    test_result["latency_ms"] = latency                    test_result["status"] = "success"                else:\n                    # Test TCP                    start_time = time.time()                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                    sock.settimeout(10)                    sock.connect((service["host"], service["port"]))                    sock.close()                    latency = (time.time() - start_time) * 1000                    test_result["latency_ms"] = latency                    test_result["status"] = "success"            except Exception as e:\n                test_result["status"] = "failed"                test_result["error"] = str(e)            latency_tests.append(test_result)        return latency_tests    \ndef analyze_network_health(self) -> Dict[str, Any]:\n        """Analizar salud general de la red"""        with self.lock:\n            current_time = datetime.now()            cutoff_time = current_time - timedelta(                minutes=10            )  # Últimos 10 minutos            # Filtrar tests recientes            recent_tests = [                test                for test in self.connection_tests                if datetime.fromisoformat(test["timestamp"]) > cutoff_time            ]            recent_latency = [                test                for test in self.latency_history                if datetime.fromisoformat(test["timestamp"]) > cutoff_time            ]            # Análisis de conectividad            connectivity_analysis = self._analyze_connectivity(recent_tests)            # Análisis de latencia            latency_analysis = self._analyze_latency(recent_latency)            # Análisis de tendencias            trend_analysis = self._analyze_trends()            return {                "timestamp":\n current_time.isoformat(),                "overall_health":\n self._calculate_overall_health(                    connectivity_analysis, latency_analysis                ),                "connectivity":\n connectivity_analysis,                "latency":\n latency_analysis,                "trends":\n trend_analysis,                "recommendations":\n self._generate_network_recommendations(                    connectivity_analysis, latency_analysis                ),            }    \ndef _analyze_connectivity(        self, recent_tests:\n List[Dict[str, Any]]    ) -> Dict[str, Any]:\n        """Analizar conectividad"""        if not recent_tests:\n            return {"status":\n "no_data", "message":\n "No hay datos recientes"}        # Contar tests exitosos por tipo        test_types = defaultdict(lambda:\n {"success":\n 0, "failed":\n 0})        for test in recent_tests:\n            for test_type, result in test["tests"].items():\n                if result["status"] == "success":\n                    test_types[test_type]["success"] += 1                else:\n                    test_types[test_type]["failed"] += 1        # Calcular porcentajes de éxito        connectivity_stats = {}        for test_type, counts in test_types.items():\n            total = counts["success"] + counts["failed"]            success_rate = (                (counts["success"] / total * 100) if total > 0 else 0            )            connectivity_stats[test_type] = {                "success_rate":\n success_rate,                "success_count":\n counts["success"],                "failed_count":\n counts["failed"],            }        # Estado general de conectividad        overall_success_rate = (            sum(stats["success_rate"] for stats in connectivity_stats.values())            / len(connectivity_stats)            if connectivity_stats            else 0        )        if overall_success_rate >= 95:\n            connectivity_status = "excellent"        elif overall_success_rate >= 80:\n            connectivity_status = "good"        elif overall_success_rate >= 60:\n            connectivity_status = "degraded"        else:\n            connectivity_status = "poor"        return {            "status":\n connectivity_status,            "overall_success_rate":\n overall_success_rate,            "test_results":\n connectivity_stats,            "total_tests":\n len(recent_tests),        }    \ndef _analyze_latency(        self, recent_latency:\n List[Dict[str, Any]]    ) -> Dict[str, Any]:\n        """Analizar latencia"""        if not recent_latency:\n            return {                "status":\n "no_data",                "message":\n "No hay datos de latencia recientes",            }        # Agrupar por servicio        service_latencies = defaultdict(list)        for test in recent_latency:\n            if test["status"] == "success" and test["latency_ms"] is not None:\n                service_latencies[test["service"]].append(test["latency_ms"])        # Calcular estadísticas por servicio        latency_stats = {}        for service, latencies in service_latencies.items():\n            if latencies:\n                latency_stats[service] = {                    "avg_latency_ms":\n statistics.mean(latencies),                    "min_latency_ms":\n min(latencies),                    "max_latency_ms":\n max(latencies),                    "median_latency_ms":\n statistics.median(latencies),                    "test_count":\n len(latencies),                }        # Calcular latencia promedio general        all_latencies = [            lat            for latencies in service_latencies.values()            for lat in latencies        ]        overall_avg_latency = (            statistics.mean(all_latencies) if all_latencies else 0        )        # Determinar estado de latencia        if overall_avg_latency < 100:\n            latency_status = "excellent"        elif overall_avg_latency < 300:\n            latency_status = "good"        elif overall_avg_latency < 1000:\n            latency_status = "degraded"        else:\n            latency_status = "poor"        return {            "status":\n latency_status,            "overall_avg_latency_ms":\n overall_avg_latency,            "service_stats":\n latency_stats,            "total_tests":\n len(recent_latency),        }    \ndef _analyze_trends(self) -> Dict[str, Any]:\n        """Analizar tendencias de red"""        with self.lock:\n            if len(self.latency_history) < 10:\n                return {"status":\n "insufficient_data"}            # Analizar tendencia de latencia            recent_latencies = list(self.latency_history)[                -20:\n            ]  # Últimos 20 tests            successful_tests = [                test                for test in recent_latencies                if test["status"] == "success"            ]            if len(successful_tests) < 5:\n                return {"status":\n "insufficient_successful_tests"}            # Calcular tendencia            latencies = [test["latency_ms"] for test in successful_tests]            if len(latencies) >= 2:\n                # Tendencia simple:\n comparar primera mitad vs segunda mitad                mid_point = len(latencies) // 2                first_half_avg = statistics.mean(latencies[:\nmid_point])                second_half_avg = statistics.mean(latencies[mid_point:\n])                trend_direction = (                    "improving"                    if second_half_avg < first_half_avg                    else "degrading"                )                trend_magnitude = abs(second_half_avg - first_half_avg)                return {                    "status":\n "analyzed",                    "trend_direction":\n trend_direction,                    "trend_magnitude_ms":\n trend_magnitude,                    "first_half_avg_ms":\n first_half_avg,                    "second_half_avg_ms":\n second_half_avg,                }            return {"status":\n "insufficient_data"}    \ndef _calculate_overall_health(        self, connectivity:\n Dict[str, Any], latency:\n Dict[str, Any]    ) -> str:\n        """Calcular salud general de la red"""        connectivity_status = connectivity.get("status", "unknown")        latency_status = latency.get("status", "unknown")        # Mapear estados a números para cálculo        status_scores = {            "excellent":\n 4,            "good":\n 3,            "degraded":\n 2,            "poor":\n 1,            "unknown":\n 0,            "no_data":\n 0,        }        connectivity_score = status_scores.get(connectivity_status, 0)        latency_score = status_scores.get(latency_status, 0)        avg_score = (connectivity_score + latency_score) / 2        if avg_score >= 3.5:\n            return "excellent"        elif avg_score >= 2.5:\n            return "good"        elif avg_score >= 1.5:\n            return "degraded"        else:\n            return "poor"    \ndef _generate_network_recommendations(        self, connectivity:\n Dict[str, Any], latency:\n Dict[str, Any]    ) -> List[str]:\n        """Generar recomendaciones de red"""        recommendations = []        # Recomendaciones basadas en conectividad        connectivity_status = connectivity.get("status", "unknown")        if connectivity_status == "poor":\n            recommendations.append(                "🔴 Conectividad crítica - Verificar configuración de red"            )        elif connectivity_status == "degraded":\n            recommendations.append(                "🟡 Conectividad degradada - Revisar DNS y firewall"            )        # Recomendaciones basadas en latencia        latency_status = latency.get("status", "unknown")        if latency_status == "poor":\n            recommendations.append(                "🔴 Latencia muy alta - Considerar CDN o servidor más cercano"            )        elif latency_status == "degraded":\n            recommendations.append(                "🟡 Latencia alta - Optimizar queries y conexiones"            )        # Recomendaciones específicas por servicio        test_results = connectivity.get("test_results", {})        for test_type, result in test_results.items():\n            if result["success_rate"] < 80:\n                if test_type == "dns":\n                    recommendations.append(                        "🔧 Problemas de DNS - Verificar configuración DNS"                    )                elif test_type == "https":\n                    recommendations.append(                        "🔒 Problemas HTTPS - Verificar certificados SSL"                    )        if not recommendations:\n            recommendations.append("✅ Red funcionando correctamente")        return recommendations# Instancia global del sistema de diagnósticonetwork_diagnostic = NetworkDiagnosticSystem()# ============================================# ENDPOINTS DE DIAGNÓSTICO DE RED# ============================================@router.get("/network-health")async \ndef get_network_health(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    🌐 Análisis completo de salud de red    """    try:\n        health_analysis = network_diagnostic.analyze_network_health()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n health_analysis,        }    except Exception as e:\n        logger.error(f"Error analizando salud de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/test-connectivity")async \ndef test_connectivity_now(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    🔍 Test inmediato de conectividad    """    try:\n        # Realizar test inmediato        test_result = network_diagnostic._test_connectivity()        # Agregar a historial        with network_diagnostic.lock:\n            network_diagnostic.connection_tests.append(test_result)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "test_result":\n test_result,        }    except Exception as e:\n        logger.error(f"Error en test de conectividad:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/test-latency")async \ndef test_latency_now(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ⚡ Test inmediato de latencia    """    try:\n        # Realizar test inmediato        latency_tests = network_diagnostic._test_latency()        # Agregar a historial        with network_diagnostic.lock:\n            for test in latency_tests:\n                network_diagnostic.latency_history.append(test)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "latency_tests":\n latency_tests,        }    except Exception as e:\n        logger.error(f"Error en test de latencia:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/network-statistics")async \ndef get_network_statistics(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    📊 Estadísticas históricas de red    """    try:\n        with network_diagnostic.lock:\n            # Estadísticas de conectividad            connectivity_stats = {                "total_tests":\n len(network_diagnostic.connection_tests),                "recent_tests":\n (                    list(network_diagnostic.connection_tests)[-10:\n]                    if network_diagnostic.connection_tests                    else []                ),            }            # Estadísticas de latencia            latency_stats = {                "total_tests":\n len(network_diagnostic.latency_history),                "recent_tests":\n (                    list(network_diagnostic.latency_history)[-20:\n]                    if network_diagnostic.latency_history                    else []                ),            }            # Calcular métricas agregadas            if network_diagnostic.latency_history:\n                all_latencies = [                    test["latency_ms"]                    for test in network_diagnostic.latency_history                    if test["status"] == "success"                    and test["latency_ms"] is not None                ]                if all_latencies:\n                    latency_stats["aggregated"] = {                        "avg_latency_ms":\n statistics.mean(all_latencies),                        "min_latency_ms":\n min(all_latencies),                        "max_latency_ms":\n max(all_latencies),                        "median_latency_ms":\n statistics.median(all_latencies),                    }        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "statistics":\n {                "connectivity":\n connectivity_stats,                "latency":\n latency_stats,            },        }    except Exception as e:\n        logger.error(f"Error obteniendo estadísticas de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/network-trends")async \ndef get_network_trends(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    📈 Análisis de tendencias de red    """    try:\n        trends = network_diagnostic._analyze_trends()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "trends":\n trends,        }    except Exception as e:\n        logger.error(f"Error analizando tendencias de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
