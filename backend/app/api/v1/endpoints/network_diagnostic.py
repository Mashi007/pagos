"""Sistema de DiagnÃ³stico de Red y LatenciaAnaliza problemas de conectividad y rendimiento de red"""\nimport logging\nimport socket\nimport statistics\nimport threading\nimport time\nimport urllib.request\nfrom collections \nimport defaultdict, deque\nfrom datetime \nimport datetime, timedelta\nfrom typing \nimport Any, Dict, List\nfrom fastapi \nimport APIRouter, Depends\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE DIAGNÃ“STICO DE RED# ============================================\nclass NetworkDiagnosticSystem:\n    """Sistema de diagnÃ³stico de red y latencia"""    \ndef __init__(self):\n        self.latency_history = deque(maxlen=1000)  # Historial de latencia        self.connection_tests = deque(maxlen=100)  # Tests de conexiÃ³n        self.network_metrics = defaultdict(list)  # MÃ©tricas de red        self.lock = threading.Lock()        # Iniciar monitoreo en background        self._start_background_monitoring()    \ndef _start_background_monitoring(self):\n        """Iniciar monitoreo de red en background"""        \ndef monitoring_loop():\n            while True:\n                try:\n                    self._perform_network_tests()                    time.sleep(60)  # Test cada minuto                except Exception as e:\n                    logger.error(f"Error en monitoreo de red:\n {e}")                    time.sleep(120)        thread = threading.Thread(target=monitoring_loop, daemon=True)        thread.start()        logger.info("ðŸŒ Sistema de diagnÃ³stico de red iniciado")    \ndef _perform_network_tests(self):\n        """Realizar tests de red periÃ³dicos"""        with self.lock:\n            # Test de conectividad bÃ¡sica            connectivity_test = self._test_connectivity()            self.connection_tests.append(connectivity_test)            # Test de latencia a servicios externos            latency_tests = self._test_latency()            for test in latency_tests:\n                self.latency_history.append(test)    \ndef _test_connectivity(self) -> Dict[str, Any]:\n        """Test bÃ¡sico de conectividad"""        test_result = {            "timestamp":\n datetime.now().isoformat(),            "tests":\n {},            "overall_status":\n "unknown",        }        # Test de DNS        try:\n            socket.gethostbyname("google.com")            test_result["tests"]["dns"] = {                "status":\n "success",                "latency_ms":\n 0,            }        except Exception as e:\n            test_result["tests"]["dns"] = {"status":\n "failed", "error":\n str(e)}        # Test de conectividad HTTP        try:\n            \nimport urllib.request            start_time = time.time()            urllib.request.urlopen("http:\n//httpbin.org/get", timeout=10)            latency = (time.time() - start_time) * 1000            test_result["tests"]["http"] = {                "status":\n "success",                "latency_ms":\n latency,            }        except Exception as e:\n            test_result["tests"]["http"] = {                "status":\n "failed",                "error":\n str(e),            }        # Test de conectividad HTTPS        try:\n            start_time = time.time()            urllib.request.urlopen("https:\n//httpbin.org/get", timeout=10)            latency = (time.time() - start_time) * 1000            test_result["tests"]["https"] = {                "status":\n "success",                "latency_ms":\n latency,            }        except Exception as e:\n            test_result["tests"]["https"] = {                "status":\n "failed",                "error":\n str(e),            }        # Determinar estado general        failed_tests = [            test            for test in test_result["tests"].values()            if test["status"] == "failed"        ]        if len(failed_tests) == 0:\n            test_result["overall_status"] = "excellent"        elif len(failed_tests) == 1:\n            test_result["overall_status"] = "good"        elif len(failed_tests) == 2:\n            test_result["overall_status"] = "degraded"        else:\n            test_result["overall_status"] = "poor"        return test_result    \ndef _test_latency(self) -> List[Dict[str, Any]]:\n        """Test de latencia a varios servicios"""        latency_tests = []        # Servicios a testear        services = [            {"name":\n "google_dns", "host":\n "8.8.8.8", "port":\n 53},            {"name":\n "cloudflare_dns", "host":\n "1.1.1.1", "port":\n 53},            {"name":\n "google_http", "url":\n "https:\n//www.google.com"},            {"name":\n "cloudflare_http", "url":\n "https:\n//www.cloudflare.com"},        ]        for service in services:\n            test_result = {                "service":\n service["name"],                "timestamp":\n datetime.now().isoformat(),                "latency_ms":\n None,                "status":\n "unknown",                "error":\n None,            }            try:\n                if "url" in service:\n                    # Test HTTP/HTTPS                    start_time = time.time()                    urllib.request.urlopen(service["url"], timeout=10)                    latency = (time.time() - start_time) * 1000                    test_result["latency_ms"] = latency                    test_result["status"] = "success"                else:\n                    # Test TCP                    start_time = time.time()                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                    sock.settimeout(10)                    sock.connect((service["host"], service["port"]))                    sock.close()                    latency = (time.time() - start_time) * 1000                    test_result["latency_ms"] = latency                    test_result["status"] = "success"            except Exception as e:\n                test_result["status"] = "failed"                test_result["error"] = str(e)            latency_tests.append(test_result)        return latency_tests    \ndef analyze_network_health(self) -> Dict[str, Any]:\n        """Analizar salud general de la red"""        with self.lock:\n            current_time = datetime.now()            cutoff_time = current_time - timedelta(                minutes=10            )  # Ãšltimos 10 minutos            # Filtrar tests recientes            recent_tests = [                test                for test in self.connection_tests                if datetime.fromisoformat(test["timestamp"]) > cutoff_time            ]            recent_latency = [                test                for test in self.latency_history                if datetime.fromisoformat(test["timestamp"]) > cutoff_time            ]            # AnÃ¡lisis de conectividad            connectivity_analysis = self._analyze_connectivity(recent_tests)            # AnÃ¡lisis de latencia            latency_analysis = self._analyze_latency(recent_latency)            # AnÃ¡lisis de tendencias            trend_analysis = self._analyze_trends()            return {                "timestamp":\n current_time.isoformat(),                "overall_health":\n self._calculate_overall_health(                    connectivity_analysis, latency_analysis                ),                "connectivity":\n connectivity_analysis,                "latency":\n latency_analysis,                "trends":\n trend_analysis,                "recommendations":\n self._generate_network_recommendations(                    connectivity_analysis, latency_analysis                ),            }    \ndef _analyze_connectivity(        self, recent_tests:\n List[Dict[str, Any]]    ) -> Dict[str, Any]:\n        """Analizar conectividad"""        if not recent_tests:\n            return {"status":\n "no_data", "message":\n "No hay datos recientes"}        # Contar tests exitosos por tipo        test_types = defaultdict(lambda:\n {"success":\n 0, "failed":\n 0})        for test in recent_tests:\n            for test_type, result in test["tests"].items():\n                if result["status"] == "success":\n                    test_types[test_type]["success"] += 1                else:\n                    test_types[test_type]["failed"] += 1        # Calcular porcentajes de Ã©xito        connectivity_stats = {}        for test_type, counts in test_types.items():\n            total = counts["success"] + counts["failed"]            success_rate = (                (counts["success"] / total * 100) if total > 0 else 0            )            connectivity_stats[test_type] = {                "success_rate":\n success_rate,                "success_count":\n counts["success"],                "failed_count":\n counts["failed"],            }        # Estado general de conectividad        overall_success_rate = (            sum(stats["success_rate"] for stats in connectivity_stats.values())            / len(connectivity_stats)            if connectivity_stats            else 0        )        if overall_success_rate >= 95:\n            connectivity_status = "excellent"        elif overall_success_rate >= 80:\n            connectivity_status = "good"        elif overall_success_rate >= 60:\n            connectivity_status = "degraded"        else:\n            connectivity_status = "poor"        return {            "status":\n connectivity_status,            "overall_success_rate":\n overall_success_rate,            "test_results":\n connectivity_stats,            "total_tests":\n len(recent_tests),        }    \ndef _analyze_latency(        self, recent_latency:\n List[Dict[str, Any]]    ) -> Dict[str, Any]:\n        """Analizar latencia"""        if not recent_latency:\n            return {                "status":\n "no_data",                "message":\n "No hay datos de latencia recientes",            }        # Agrupar por servicio        service_latencies = defaultdict(list)        for test in recent_latency:\n            if test["status"] == "success" and test["latency_ms"] is not None:\n                service_latencies[test["service"]].append(test["latency_ms"])        # Calcular estadÃ­sticas por servicio        latency_stats = {}        for service, latencies in service_latencies.items():\n            if latencies:\n                latency_stats[service] = {                    "avg_latency_ms":\n statistics.mean(latencies),                    "min_latency_ms":\n min(latencies),                    "max_latency_ms":\n max(latencies),                    "median_latency_ms":\n statistics.median(latencies),                    "test_count":\n len(latencies),                }        # Calcular latencia promedio general        all_latencies = [            lat            for latencies in service_latencies.values()            for lat in latencies        ]        overall_avg_latency = (            statistics.mean(all_latencies) if all_latencies else 0        )        # Determinar estado de latencia        if overall_avg_latency < 100:\n            latency_status = "excellent"        elif overall_avg_latency < 300:\n            latency_status = "good"        elif overall_avg_latency < 1000:\n            latency_status = "degraded"        else:\n            latency_status = "poor"        return {            "status":\n latency_status,            "overall_avg_latency_ms":\n overall_avg_latency,            "service_stats":\n latency_stats,            "total_tests":\n len(recent_latency),        }    \ndef _analyze_trends(self) -> Dict[str, Any]:\n        """Analizar tendencias de red"""        with self.lock:\n            if len(self.latency_history) < 10:\n                return {"status":\n "insufficient_data"}            # Analizar tendencia de latencia            recent_latencies = list(self.latency_history)[                -20:\n            ]  # Ãšltimos 20 tests            successful_tests = [                test                for test in recent_latencies                if test["status"] == "success"            ]            if len(successful_tests) < 5:\n                return {"status":\n "insufficient_successful_tests"}            # Calcular tendencia            latencies = [test["latency_ms"] for test in successful_tests]            if len(latencies) >= 2:\n                # Tendencia simple:\n comparar primera mitad vs segunda mitad                mid_point = len(latencies) // 2                first_half_avg = statistics.mean(latencies[:\nmid_point])                second_half_avg = statistics.mean(latencies[mid_point:\n])                trend_direction = (                    "improving"                    if second_half_avg < first_half_avg                    else "degrading"                )                trend_magnitude = abs(second_half_avg - first_half_avg)                return {                    "status":\n "analyzed",                    "trend_direction":\n trend_direction,                    "trend_magnitude_ms":\n trend_magnitude,                    "first_half_avg_ms":\n first_half_avg,                    "second_half_avg_ms":\n second_half_avg,                }            return {"status":\n "insufficient_data"}    \ndef _calculate_overall_health(        self, connectivity:\n Dict[str, Any], latency:\n Dict[str, Any]    ) -> str:\n        """Calcular salud general de la red"""        connectivity_status = connectivity.get("status", "unknown")        latency_status = latency.get("status", "unknown")        # Mapear estados a nÃºmeros para cÃ¡lculo        status_scores = {            "excellent":\n 4,            "good":\n 3,            "degraded":\n 2,            "poor":\n 1,            "unknown":\n 0,            "no_data":\n 0,        }        connectivity_score = status_scores.get(connectivity_status, 0)        latency_score = status_scores.get(latency_status, 0)        avg_score = (connectivity_score + latency_score) / 2        if avg_score >= 3.5:\n            return "excellent"        elif avg_score >= 2.5:\n            return "good"        elif avg_score >= 1.5:\n            return "degraded"        else:\n            return "poor"    \ndef _generate_network_recommendations(        self, connectivity:\n Dict[str, Any], latency:\n Dict[str, Any]    ) -> List[str]:\n        """Generar recomendaciones de red"""        recommendations = []        # Recomendaciones basadas en conectividad        connectivity_status = connectivity.get("status", "unknown")        if connectivity_status == "poor":\n            recommendations.append(                "ðŸ”´ Conectividad crÃ­tica - Verificar configuraciÃ³n de red"            )        elif connectivity_status == "degraded":\n            recommendations.append(                "ðŸŸ¡ Conectividad degradada - Revisar DNS y firewall"            )        # Recomendaciones basadas en latencia        latency_status = latency.get("status", "unknown")        if latency_status == "poor":\n            recommendations.append(                "ðŸ”´ Latencia muy alta - Considerar CDN o servidor mÃ¡s cercano"            )        elif latency_status == "degraded":\n            recommendations.append(                "ðŸŸ¡ Latencia alta - Optimizar queries y conexiones"            )        # Recomendaciones especÃ­ficas por servicio        test_results = connectivity.get("test_results", {})        for test_type, result in test_results.items():\n            if result["success_rate"] < 80:\n                if test_type == "dns":\n                    recommendations.append(                        "ðŸ”§ Problemas de DNS - Verificar configuraciÃ³n DNS"                    )                elif test_type == "https":\n                    recommendations.append(                        "ðŸ”’ Problemas HTTPS - Verificar certificados SSL"                    )        if not recommendations:\n            recommendations.append("âœ… Red funcionando correctamente")        return recommendations# Instancia global del sistema de diagnÃ³sticonetwork_diagnostic = NetworkDiagnosticSystem()# ============================================# ENDPOINTS DE DIAGNÃ“STICO DE RED# ============================================@router.get("/network-health")async \ndef get_network_health(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸŒ AnÃ¡lisis completo de salud de red    """    try:\n        health_analysis = network_diagnostic.analyze_network_health()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n health_analysis,        }    except Exception as e:\n        logger.error(f"Error analizando salud de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/test-connectivity")async \ndef test_connectivity_now(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ” Test inmediato de conectividad    """    try:\n        # Realizar test inmediato        test_result = network_diagnostic._test_connectivity()        # Agregar a historial        with network_diagnostic.lock:\n            network_diagnostic.connection_tests.append(test_result)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "test_result":\n test_result,        }    except Exception as e:\n        logger.error(f"Error en test de conectividad:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.post("/test-latency")async \ndef test_latency_now(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    âš¡ Test inmediato de latencia    """    try:\n        # Realizar test inmediato        latency_tests = network_diagnostic._test_latency()        # Agregar a historial        with network_diagnostic.lock:\n            for test in latency_tests:\n                network_diagnostic.latency_history.append(test)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "latency_tests":\n latency_tests,        }    except Exception as e:\n        logger.error(f"Error en test de latencia:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/network-statistics")async \ndef get_network_statistics(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ“Š EstadÃ­sticas histÃ³ricas de red    """    try:\n        with network_diagnostic.lock:\n            # EstadÃ­sticas de conectividad            connectivity_stats = {                "total_tests":\n len(network_diagnostic.connection_tests),                "recent_tests":\n (                    list(network_diagnostic.connection_tests)[-10:\n]                    if network_diagnostic.connection_tests                    else []                ),            }            # EstadÃ­sticas de latencia            latency_stats = {                "total_tests":\n len(network_diagnostic.latency_history),                "recent_tests":\n (                    list(network_diagnostic.latency_history)[-20:\n]                    if network_diagnostic.latency_history                    else []                ),            }            # Calcular mÃ©tricas agregadas            if network_diagnostic.latency_history:\n                all_latencies = [                    test["latency_ms"]                    for test in network_diagnostic.latency_history                    if test["status"] == "success"                    and test["latency_ms"] is not None                ]                if all_latencies:\n                    latency_stats["aggregated"] = {                        "avg_latency_ms":\n statistics.mean(all_latencies),                        "min_latency_ms":\n min(all_latencies),                        "max_latency_ms":\n max(all_latencies),                        "median_latency_ms":\n statistics.median(all_latencies),                    }        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "statistics":\n {                "connectivity":\n connectivity_stats,                "latency":\n latency_stats,            },        }    except Exception as e:\n        logger.error(f"Error obteniendo estadÃ­sticas de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/network-trends")async \ndef get_network_trends(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    ðŸ“ˆ AnÃ¡lisis de tendencias de red    """    try:\n        trends = network_diagnostic._analyze_trends()        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "trends":\n trends,        }    except Exception as e:\n        logger.error(f"Error analizando tendencias de red:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
