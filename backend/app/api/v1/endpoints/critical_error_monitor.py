"""Sistema de Monitoreo de Errores Cr칤ticosMonitorea espec칤ficamente errores que causan fallos de despliegue y 503"""import loggingimport threadingfrom collections import defaultdict, dequefrom datetime import datetimefrom typing import Any, Dict, Listfrom fastapi import APIRouter, Depends, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom app.api.deps import get_current_user, get_dbfrom app.models.user import Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE MONITOREO DE ERRORES CR칈TICOS# ============================================class CriticalErrorMonitor:    """Monitor espec칤fico para errores cr칤ticos que causan fallos de d \    espliegue"""    def __init__(self):        self.critical_errors = deque(maxlen=1000)        self.deployment_failures = deque(maxlen=100)        self.import_errors = deque(maxlen=100)        self.schema_errors = deque(maxlen=100)        self.frontend_errors = deque(maxlen=100)        self.lock = threading.Lock()        # Patrones de errores cr칤ticos identificados        self.critical_patterns = {            "import_errors": [                "NameError: name",                "ImportError:",                "ModuleNotFoundError:",                "AttributeError:",            ],            "schema_errors": [                "UndefinedColumn",                'column ".*" does not exist',                'relation ".*" does not exist',            ],            "deployment_errors": [                "Port scan timeout",                "no open ports detected",                "Stopping parent process",            ],            "frontend_errors": [                "Cannot read properties of undefined",                "TypeError:",                "ReferenceError:",            ],        }    def log_critical_error(self, error_type: str, error_data: Dict[str, Any]):        """Registrar error cr칤tico espec칤fico"""        with self.lock:            error_entry = {                "timestamp": datetime.now(),                "error_type": error_type,                "error_data": error_data,                "severity": self._determine_severity(error_type, error_data),                "pattern_matched": self._match_error_patterns(                    error_data.get("message", "")                ),            }            self.critical_errors.append(error_entry)            # Clasificar por tipo            if error_type == "deployment_failure":                self.deployment_failures.append(error_entry)            elif error_type == "import_error":                self.import_errors.append(error_entry)            elif error_type == "schema_error":                self.schema_errors.append(error_entry)            elif error_type == "frontend_error":                self.frontend_errors.append(error_entry)            logger.critical(                f"游뚿 Error cr칤tico registrado: {error_type} - {error_data.get \                ('message', '')}"            )    def _determine_severity(        self, error_type: str, error_data: Dict[str, Any]    ) -> str:        """Determinar severidad del error"""        message = error_data.get("message", "").lower()        if "deque" in message and "not defined" in message:            return "critical"  # Causa fallo de despliegue        elif "undefinedcolumn" in message:            return "critical"  # Causa errores 503        elif "port scan timeout" in message:            return "critical"  # Causa fallo de despliegue        elif "cannot read properties of undefined" in message:            return "high"  # Causa errores de frontend        return "medium"    def _match_error_patterns(self, message: str) -> List[str]:        """Identificar patrones de error espec칤ficos"""        matched_patterns = []        for category, patterns in self.critical_patterns.items():            for pattern in patterns:                if pattern.lower() in message.lower():                    matched_patterns.append(f"{category}:{pattern}")        return matched_patterns    def analyze_critical_error_trends(self) -> Dict[str, Any]:        """Analizar tendencias de errores cr칤ticos"""        with self.lock:            if not self.critical_errors:                return {"error": "No hay errores cr칤ticos registrados"}            analysis = {                "timestamp": datetime.now().isoformat(),                "total_critical_errors": len(self.critical_errors),                "error_distribution": self._analyze_error_distribution(),                "severity_analysis": self._analyze_severity_distribution(),                "pattern_analysis": self._analyze_pattern_distribution(),                "trend_analysis": self._analyze_error_trends(),                "recommendations": self._generate_recommendations(),            }            return analysis    def _analyze_error_distribution(self) -> Dict[str, int]:        """Analizar distribuci칩n de tipos de error"""        distribution = defaultdict(int)        for error in self.critical_errors:            distribution[error["error_type"]] += 1        return dict(distribution)    def _analyze_severity_distribution(self) -> Dict[str, int]:        """Analizar distribuci칩n de severidad"""        severity_dist = defaultdict(int)        for error in self.critical_errors:            severity_dist[error["severity"]] += 1        return dict(severity_dist)    def _analyze_pattern_distribution(self) -> Dict[str, int]:        """Analizar distribuci칩n de patrones"""        pattern_dist = defaultdict(int)        for error in self.critical_errors:            for pattern in error["pattern_matched"]:                pattern_dist[pattern] += 1        return dict(pattern_dist)    def _analyze_error_trends(self) -> Dict[str, Any]:        """Analizar tendencias temporales de errores"""        if len(self.critical_errors) < 2:            return {"error": "Datos insuficientes para an치lisis de tendencias"}        # Agrupar por hora        hourly_errors = defaultdict(int)        for error in self.critical_errors:            hour = error["timestamp"].hour            hourly_errors[hour] += 1        return {            "hourly_distribution": dict(hourly_errors),            "peak_error_hour": (                max(hourly_errors.items(), key=lambda x: x[1])[0]                if hourly_errors                else None            ),            "error_frequency": len(self.critical_errors)            / 24,  # Errores por hora promedio        }    def _generate_recommendations(self) -> List[Dict[str, Any]]:        """Generar recomendaciones espec칤ficas basadas en errores"""        recommendations = []        # Analizar errores m치s frecuentes        error_counts = defaultdict(int)        for error in self.critical_errors:            error_counts[error["error_type"]] += 1        most_frequent = (            max(error_counts.items(), key=lambda x: x[1])            if error_counts            else None        )        if most_frequent:            error_type, count = most_frequent            if error_type == "import_error":                recommendations.append(                    {                        "type": "import_fix",                        "priority": "critical",                        "description": "Corregir imports faltantes que \                        causan fallos de despliegue",                        "action": "Verificar y corregir imports en otros    archivos",                        "impact": "Resuelve fallos de despliegue",                    }                )            elif error_type == "schema_error":                recommendations.append(                    {                        "type": "schema_fix",                        "priority": "critical",                        "description": "Corregir inconsistencias de esquema \                        que causan errores 503",                        "action": "Agregar columna created_at a tabla    analistas o corregir queries",                        "impact": "Resuelve errores 503 en endpoints",                    }                )            elif error_type == "deployment_failure":                recommendations.append(                    {                        "type": "deployment_fix",                        "priority": "critical",                        "description": "Resolver problemas de despliegue    que causan timeouts",                        "action": "Verificar configuraci칩n de puertos y    dependencias",                        "impact": "Permite despliegues exitosos",                    }                )        return recommendations    def get_critical_error_summary(self) -> Dict[str, Any]:        """Obtener resumen de errores cr칤ticos"""        with self.lock:            return {                "timestamp": datetime.now().isoformat(),                "summary": {                    "total_critical_errors": len(self.critical_errors),                    "deployment_failures": len(self.deployment_failures),                    "import_errors": len(self.import_errors),                    "schema_errors": len(self.schema_errors),                    "frontend_errors": len(self.frontend_errors),                    "last_error": (                        self.critical_errors[-1]                        if self.critical_errors                        else None                    ),                },            }# Instancia global del monitor de errores cr칤ticoscritical_error_monitor = CriticalErrorMonitor()# ============================================# ENDPOINTS DE MONITOREO DE ERRORES CR칈TICOS# ============================================@router.post("/log-critical-error")async def log_critical_error_endpoint(    error_data: Dict[str, Any],    db: Session = Depends(get_db),    current_user: User = Depends(get_current_user),):    """    游뚿 Registrar error cr칤tico espec칤fico    """    try:        error_type = error_data.get("error_type")        error_details = error_data.get("error_details", {})        if not error_type:            raise HTTPException(status_code=400, detail="error_type requerido")        critical_error_monitor.log_critical_error(error_type, error_details)        return {            "timestamp": datetime.now().isoformat(),            "status": "logged",            "message": "Error cr칤tico registrado",        }    except HTTPException:        raise    except Exception as e:        logger.error(f"Error registrando error cr칤tico: {e}")        return {            "timestamp": datetime.now().isoformat(),            "status": "error",            "error": str(e),        }@router.get("/critical-error-analysis")async def get_critical_error_analysis(    db: Session = Depends(get_db),    current_user: User = Depends(get_current_user),):    """    游늵 An치lisis de tendencias de errores cr칤ticos    """    try:        analysis = critical_error_monitor.analyze_critical_error_trends()        return {            "timestamp": datetime.now().isoformat(),            "status": "success",            "analysis": analysis,        }    except Exception as e:        logger.error(f"Error analizando errores cr칤ticos: {e}")        return {            "timestamp": datetime.now().isoformat(),            "status": "error",            "error": str(e),        }@router.get("/critical-error-summary")async def get_critical_error_summary_endpoint(    db: Session = Depends(get_db),    current_user: User = Depends(get_current_user),):    """    游늶 Resumen de errores cr칤ticos    """    try:        summary = critical_error_monitor.get_critical_error_summary()        return {            "timestamp": datetime.now().isoformat(),            "status": "success",            "summary": summary,        }    except Exception as e:        logger.error(f"Error obteniendo resumen de errores cr칤ticos: {e}")        return {            "timestamp": datetime.now().isoformat(),            "status": "error",            "error": str(e),        }