"""Endpoint de diagn√≥stico espec√≠fico para problemas de refresh token"""\nimport logging\nfrom datetime \nimport datetime\nimport jwt\nfrom fastapi \nimport APIRouter, Depends, HTTPException, Request\nfrom jwt \nimport PyJWTError\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.core.config \nimport settings\nfrom app.core.security \nimport (    create_access_token,    create_refresh_token,    decode_token,)\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()@router.post("/diagnosticar-refresh-token")async \ndef diagnosticar_refresh_token(    request:\n Request, db:\n Session = Depends(get_db)):\n    """    üîç Diagn√≥stico espec√≠fico para problemas de refresh token    """    try:\n        logger.info("üîç Iniciando diagn√≥stico de refresh token")        # Obtener refresh token del body        body = await request.json()        refresh_token = body.get("refresh_token")        if not refresh_token:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n "No refresh token provided",                "recomendacion":\n (                    "Verificar que el frontend est√© enviando el refresh_token \                    correctamente"                ),            }        logger.info(f"üîç Refresh token recibido:\n {refresh_token[:\n20]}...")        # 1. Verificar formato del token        try:\n            # Decodificar sin verificar para obtener informaci√≥n b√°sica            payload_unverified = jwt.decode(                refresh_token, options={"verify_signature":\n False}            )            token_info = {                "formato_valido":\n True,                "payload_keys":\n list(payload_unverified.keys()),                "user_id":\n payload_unverified.get("sub"),                "token_type":\n payload_unverified.get("type"),                "exp":\n payload_unverified.get("exp"),                "iat":\n payload_unverified.get("iat"),            }            # Verificar si est√° expirado            if payload_unverified.get("exp"):\n                exp_timestamp = payload_unverified["exp"]                exp_datetime = datetime.fromtimestamp(exp_timestamp)                now = datetime.now()                token_info["expired"] = now > exp_datetime                token_info["expires_at"] = exp_datetime.isoformat()                token_info["time_until_expiry"] = (                    str(exp_datetime - now)                    if not token_info["expired"]                    else "EXPIRED"                )        except Exception as e:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n f"Token format invalid:\n {str(e)}",                "recomendacion":\n "El refresh token tiene un formato inv√°lido",            }        # 2. Verificar con decode_token (con verificaci√≥n)        try:\n            payload_verified = decode_token(refresh_token)            token_info["verificacion_firma"] = "SUCCESS"            token_info["payload_verificado"] = payload_verified        except PyJWTError as e:\n            token_info["verificacion_firma"] = "FAILED"            token_info["error_verificacion"] = str(e)            if "expired" in str(e).lower():\n                return {                    "timestamp":\n datetime.now().isoformat(),                    "status":\n "error",                    "error":\n "Refresh token expired",                    "token_info":\n token_info,                    "recomendacion":\n (                        "El refresh token ha expirado. El usuario debe \                        hacer login nuevamente."                    ),                }            else:\n                return {                    "timestamp":\n datetime.now().isoformat(),                    "status":\n "error",                    "error":\n f"Token verification failed:\n {str(e)}",                    "token_info":\n token_info,                    "recomendacion":\n "El refresh token es inv√°lido o    corrupto.",                }        # 3. Verificar tipo de token        if payload_verified.get("type") != "refresh":\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n "Token type is not 'refresh'",                "token_info":\n token_info,                "recomendacion":\n "El token enviado no es un refresh token    v√°lido.",            }        # 4. Verificar usuario en BD        user_id = payload_verified.get("sub")        if not user_id:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n "No user ID in token",                "token_info":\n token_info,                "recomendacion":\n "El refresh token no contiene un user_id    v√°lido.",            }        user = db.query(User).filter(User.id == int(user_id)).first()        if not user:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n "User not found",                "token_info":\n token_info,                "recomendacion":\n f"Usuario con ID {user_id} no existe en    la base de datos.",            }        if not user.is_active:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n "User inactive",                "token_info":\n token_info,                "user_info":\n {                    "email":\n user.email,                    "active":\n user.is_active,                    "admin":\n user.is_admin,                },                "recomendacion":\n "El usuario est√° inactivo. Contactar    administrador.",            }        # 5. Intentar generar nuevos tokens        try:\n            new_access_token = create_access_token(                subject=user.id,                additional_claims={                    "is_admin":\n user.is_admin,                    "email":\n user.email,                },            )            new_refresh_token = create_refresh_token(subject=user.id)            token_info["nuevos_tokens_generados"] = True            token_info["usuario_valido"] = True            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "success",                "message":\n "Refresh token v√°lido y nuevos tokens generados",                "token_info":\n token_info,                "user_info":\n {                    "email":\n user.email,                    "active":\n user.is_active,                    "admin":\n user.is_admin,                },                "nuevos_tokens":\n {                    "access_token":\n new_access_token,                    "refresh_token":\n new_refresh_token,                },                "recomendacion":\n (                    "El refresh token es v√°lido. El problema puede estar    en el frontend."                ),            }        except Exception as e:\n            return {                "timestamp":\n datetime.now().isoformat(),                "status":\n "error",                "error":\n f"Error generating new tokens:\n {str(e)}",                "token_info":\n token_info,                "recomendacion":\n "Error interno al generar nuevos tokens.",            }    except Exception as e:\n        logger.error(f"‚ùå Error en diagn√≥stico de refresh token:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n f"Error interno:\n {str(e)}",            "recomendacion":\n "Error interno del servidor.",        }@router.get("/estado-refresh-tokens")async \ndef estado_refresh_tokens(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üìä Estado general de los refresh tokens en el sistema    """    try:\n        logger.info(            f"üìä Verificando estado de refresh tokens -     Usuario:\n {current_user.email}"        )        # Informaci√≥n del usuario actual        user_info = {            "id":\n current_user.id,            "email":\n current_user.email,            "active":\n current_user.is_active,            "admin":\n current_user.is_admin,        }        # Generar tokens de prueba para el usuario actual        test_access_token = create_access_token(            subject=current_user.id,            additional_claims={                "is_admin":\n current_user.is_admin,                "email":\n current_user.email,            },        )        test_refresh_token = create_refresh_token(subject=current_user.id)        return {            "timestamp":\n datetime.now().isoformat(),            "usuario":\n user_info,            "tokens_generados":\n {                "access_token":\n test_access_token,                "refresh_token":\n test_refresh_token,            },            "configuracion":\n {                "jwt_secret_key":\n (                    "CONFIGURED" if settings.SECRET_KEY else "NOT_CONFIGURED"                ),                "jwt_algorithm":\n "HS256",                "access_token_expire_minutes":\n 30,                "refresh_token_expire_days":\n 7,            },            "recomendacion":\n (                "Tokens generados correctamente. Verificar configuraci√≥n    del frontend."            ),        }    except Exception as e:\n        logger.error(f"‚ùå Error verificando estado de refresh tokens:\n {e}")        raise HTTPException(            status_code=500,            detail=f"Error verificando estado de refresh tokens:\n {str(e)}",        )
