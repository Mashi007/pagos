"""Sistema de An√°lisis de Esquema de Base de DatosIdentifica inconsistencias espec√≠ficas entre modelos y esquema real"""\nimport logging\nimport threading\nfrom collections \nimport deque\nfrom datetime \nimport datetime\nfrom typing \nimport Any, Dict\nfrom fastapi \nimport APIRouter, Depends\nfrom sqlalchemy.orm \nimport Session\nfrom app.api.deps \nimport get_current_user, get_db\nfrom app.models.user \nimport Userlogger = logging.getLogger(__name__)router = APIRouter()# ============================================# SISTEMA DE AN√ÅLISIS DE ESQUEMA DE BD# ============================================\nclass DatabaseSchemaAnalyzer:\n    """Analizador espec√≠fico para inconsistencias de esquema de BD"""    \ndef __init__(self):\n        self.schema_inconsistencies = deque(maxlen=1000)        self.model_vs_schema_analysis = {}        self.critical_tables = ["analistas", "clientes", "users", "usuarios"]        self.expected_columns = {            "analistas":\n [                "id",                "nombre",                "activo",                "created_at",                "updated_at",            ],            "clientes":\n [                "id",                "cedula",                "nombres",                "apellidos",                "estado",                "created_at",                "updated_at",                "fecha_registro",            ],            "users":\n ["id", "email", "is_active", "created_at", "updated_at"],            "usuarios":\n [                "id",                "email",                "is_active",                "created_at",                "updated_at",            ],        }        self.lock = threading.Lock()    \ndef analyze_schema_inconsistencies(self, db:\n Session) -> Dict[str, Any]:\n        """Analizar inconsistencias espec√≠ficas del esquema"""        with self.lock:\n            analysis = {                "timestamp":\n datetime.now().isoformat(),                "critical_issues":\n [],                "schema_analysis":\n {},                "recommendations":\n [],            }            for table in self.critical_tables:\n                table_analysis = self._analyze_table_schema(db, table)                analysis["schema_analysis"][table] = table_analysis                if table_analysis["critical_issues"]:\n                    analysis["critical_issues"].extend(                        table_analysis["critical_issues"]                    )            return analysis    \ndef _analyze_table_schema(        self, db:\n Session, table_name:\n str    ) -> Dict[str, Any]:\n        """Analizar esquema espec√≠fico de una tabla"""        try:\n            # Obtener columnas reales de la BD            query = """            SELECT column_name, data_type, is_nullable, column_default            \nfrom information_schema.columns            WHERE table_schema = 'public' AND table_name = %s            ORDER BY ordinal_position            """            result = db.execute(query, (table_name,))            real_columns = [row[0] for row in result.fetchall()]            # Comparar con columnas esperadas            expected = self.expected_columns.get(table_name, [])            missing_columns = [                col for col in expected if col not in real_columns            ]            extra_columns = [                col for col in real_columns if col not in expected            ]            critical_issues = []            if missing_columns:\n                critical_issues.append(                    {                        "type":\n "missing_columns",                        "table":\n table_name,                        "columns":\n missing_columns,                        "severity":\n "critical",                        "impact":\n "causes_503_errors",                    }                )            if extra_columns:\n                critical_issues.append(                    {                        "type":\n "extra_columns",                        "table":\n table_name,                        "columns":\n extra_columns,                        "severity":\n "warning",                        "impact":\n "potential_confusion",                    }                )            return {                "table_name":\n table_name,                "real_columns":\n real_columns,                "expected_columns":\n expected,                "missing_columns":\n missing_columns,                "extra_columns":\n extra_columns,                "critical_issues":\n critical_issues,                "schema_consistency":\n len(missing_columns) == 0,            }        except Exception as e:\n            logger.error(                f"Error analizando esquema de tabla {table_name}:\n {e}"            )            return {                "table_name":\n table_name,                "error":\n str(e),                "critical_issues":\n [                    {"type":\n "analysis_error", "error":\n str(e)}                ],            }    \ndef generate_schema_fixes(self, db:\n Session) -> Dict[str, Any]:\n        """Generar fixes espec√≠ficos para el esquema"""        fixes = {            "timestamp":\n datetime.now().isoformat(),            "sql_fixes":\n [],            "model_fixes":\n [],            "priority":\n "high",        }        # Fix espec√≠fico para tabla analistas        fixes["sql_fixes"].append(            {                "table":\n "analistas",                "fix_type":\n "add_column",                "sql":\n (                    "ALTER TABLE analistas ADD COLUMN created_at TIMESTAMP \                    DEFAULT CURRENT_TIMESTAMP;\n"                ),                "description":\n "Agregar columna created_at faltante que \                causa error 503",                "priority":\n "critical",            }        )        # Fix para queries que usan created_at        fixes["model_fixes"].append(            {                "file":\n "backend/app/api/v1/endpoints/analistas.py",                "fix_type":\n "query_fix",                "description":\n "Cambiar queries de created_at a updated_at    en tabla analistas",                "priority":\n "critical",            }        )        return fixes    \ndef monitor_schema_changes(self, db:\n Session) -> Dict[str, Any]:\n        """Monitorear cambios en el esquema en tiempo real"""        with self.lock:\n            current_state = {}            for table in self.critical_tables:\n                try:\n                    query = """                    SELECT column_name, data_type                    \nfrom information_schema.columns                    WHERE table_schema = 'public' AND table_name = %s                    ORDER BY ordinal_position                    """                    result = db.execute(query, (table,))                    current_state[table] = [                        row[0] for row in result.fetchall()                    ]                except Exception as e:\n                    current_state[table] = {"error":\n str(e)}            return {                "timestamp":\n datetime.now().isoformat(),                "current_schema_state":\n current_state,                "monitoring_active":\n True,            }# Instancia global del analizador de esquemaschema_analyzer = DatabaseSchemaAnalyzer()# ============================================# ENDPOINTS DE AN√ÅLISIS DE ESQUEMA# ============================================@router.get("/schema-inconsistencies")async \ndef get_schema_inconsistencies(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üîç Analizar inconsistencias espec√≠ficas del esquema de BD    """    try:\n        analysis = schema_analyzer.analyze_schema_inconsistencies(db)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "analysis":\n analysis,        }    except Exception as e:\n        logger.error(f"Error analizando inconsistencias de esquema:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/schema-fixes")async \ndef get_schema_fixes(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üîß Generar fixes espec√≠ficos para el esquema    """    try:\n        fixes = schema_analyzer.generate_schema_fixes(db)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "fixes":\n fixes,        }    except Exception as e:\n        logger.error(f"Error generando fixes de esquema:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }@router.get("/schema-monitoring")async \ndef get_schema_monitoring(    db:\n Session = Depends(get_db),    current_user:\n User = Depends(get_current_user),):\n    """    üìä Monitorear estado actual del esquema    """    try:\n        monitoring = schema_analyzer.monitor_schema_changes(db)        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "success",            "monitoring":\n monitoring,        }    except Exception as e:\n        logger.error(f"Error monitoreando esquema:\n {e}")        return {            "timestamp":\n datetime.now().isoformat(),            "status":\n "error",            "error":\n str(e),        }
